#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = []
# ///

"""Script to setup E2E secrets for test scenarios.

This script reads a secret source file and generates scenario-specific
configuration files for use in the erato-local Helm chart.
"""

import argparse
import sys
import tomllib
from pathlib import Path
from typing import Dict, Any

# Import shared utilities
from k3d_common import VALID_SCENARIOS


def get_config_dir() -> Path:
    """Get the path to the config directory."""
    script_dir = Path(__file__).resolve().parent
    infrastructure_dir = script_dir.parent
    config_dir = infrastructure_dir / "k3d" / "erato-local" / "config"
    return config_dir


def get_secret_source_path() -> Path:
    """Get the path to the secret source file."""
    return get_config_dir() / "e2e-secrets.toml"


def load_secrets() -> Dict[str, Any]:
    """Load secrets from the source file.

    Returns:
        Dictionary containing the secrets

    Raises:
        SystemExit: If file doesn't exist or has invalid syntax
    """
    secret_path = get_secret_source_path()

    if not secret_path.exists():
        print(f"Error: Secret source file not found: {secret_path}", file=sys.stderr)
        print("", file=sys.stderr)
        print("To create the file:", file=sys.stderr)
        print(f"  1. Copy the template: cp {get_config_dir() / 'e2e-secrets.template.toml'} {secret_path}", file=sys.stderr)
        print("  2. Fill in your API keys", file=sys.stderr)
        print("  3. Run: ./scripts/setup-e2e-secrets apply", file=sys.stderr)
        sys.exit(2)

    try:
        with open(secret_path, "rb") as f:
            return tomllib.load(f)
    except tomllib.TOMLDecodeError as e:
        print(f"Error: Invalid TOML syntax in {secret_path}", file=sys.stderr)
        print(f"  {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading secret file: {e}", file=sys.stderr)
        sys.exit(1)


def validate_secrets(secrets: Dict[str, Any]) -> bool:
    """Validate that required secrets are present and valid.

    Args:
        secrets: Dictionary of secrets to validate

    Returns:
        True if valid, False otherwise
    """
    errors = []

    # Check for required fields
    if "openai_api_key" not in secrets:
        errors.append("Missing required field: openai_api_key")
    elif not secrets["openai_api_key"]:
        errors.append("Field 'openai_api_key' is empty")
    elif secrets["openai_api_key"] in ["<API_KEY>", "<YOUR_API_KEY>", "YOUR_KEY_HERE"]:
        errors.append("Field 'openai_api_key' contains placeholder value - replace with actual API key")

    # Print all validation errors
    if errors:
        print("Validation errors:", file=sys.stderr)
        for error in errors:
            print(f"  - {error}", file=sys.stderr)
        return False

    return True


def generate_scenario_config(secrets: Dict[str, Any], scenario: str) -> str:
    """Generate configuration content for a specific scenario.

    Args:
        secrets: Dictionary of secrets
        scenario: Name of the scenario

    Returns:
        TOML configuration string
    """
    # Build the configuration content
    # For now, all scenarios get the same OpenAI configuration
    # In the future, this could be customized per scenario

    config_lines = [
        "# Auto-generated E2E secrets configuration",
        f"# Scenario: {scenario}",
        "# DO NOT EDIT THIS FILE MANUALLY - generated by setup-e2e-secrets",
        "",
        "[chat_providers]",
        'priority_order = ["main"]',
        "",
        "[chat_providers.providers.main]",
        'provider_kind = "openai"',
        'model_name = "gpt-4o-mini"',
        f'api_key = "{secrets["openai_api_key"]}"',
        "",
    ]

    # Add optional Anthropic API key if present
    if "anthropic_api_key" in secrets and secrets["anthropic_api_key"]:
        config_lines.extend([
            "# Anthropic provider (if needed)",
            "# [chat_providers.providers.anthropic]",
            "# provider_kind = \"anthropic\"",
            "# model_name = \"claude-3-5-sonnet-20241022\"",
            f"# api_key = \"{secrets['anthropic_api_key']}\"",
            "",
        ])

    return "\n".join(config_lines)


def cmd_check(args: argparse.Namespace) -> int:
    """Check if E2E secrets are properly configured.

    Returns:
        0 if valid, non-zero otherwise
    """
    print("Checking E2E secrets configuration...")

    # Load secrets
    try:
        secrets = load_secrets()
    except SystemExit as e:
        return e.code

    # Validate secrets
    if not validate_secrets(secrets):
        return 1

    # Check if output files exist
    config_dir = get_config_dir()
    missing_files = []
    for scenario in VALID_SCENARIOS:
        output_file = config_dir / f"erato.scenario-{scenario}.auto.toml"
        if not output_file.exists():
            missing_files.append(output_file.name)

    if missing_files:
        print(f"Warning: Generated files missing: {', '.join(missing_files)}", file=sys.stderr)
        print("Run: ./scripts/setup-e2e-secrets apply", file=sys.stderr)
        return 1

    print("✓ E2E secrets are properly configured")
    return 0


def cmd_apply(args: argparse.Namespace) -> int:
    """Apply E2E secrets by generating scenario-specific config files.

    Returns:
        0 if successful, non-zero otherwise
    """
    print("Applying E2E secrets configuration...")

    # Load secrets
    try:
        secrets = load_secrets()
    except SystemExit as e:
        return e.code

    # Validate secrets
    if not validate_secrets(secrets):
        return 1

    # Generate config files for each scenario
    config_dir = get_config_dir()
    generated_files = []

    for scenario in VALID_SCENARIOS:
        output_file = config_dir / f"erato.scenario-{scenario}.auto.toml"

        try:
            config_content = generate_scenario_config(secrets, scenario)
            output_file.write_text(config_content)
            generated_files.append(output_file.name)
            print(f"  ✓ Generated {output_file.name}")
        except Exception as e:
            print(f"Error writing {output_file}: {e}", file=sys.stderr)
            return 1

    print()
    print(f"Successfully generated {len(generated_files)} scenario configuration files")
    return 0


def main():
    parser = argparse.ArgumentParser(
        description="Setup E2E secrets for test scenarios",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Commands:
  check   Validate that secrets are properly configured
  apply   Generate scenario-specific configuration files from secrets

Secret source file: {get_secret_source_path()}

Available scenarios: {', '.join(VALID_SCENARIOS)}
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")
    subparsers.required = True

    # check command
    parser_check = subparsers.add_parser(
        "check",
        help="Validate E2E secrets configuration"
    )
    parser_check.set_defaults(func=cmd_check)

    # apply command
    parser_apply = subparsers.add_parser(
        "apply",
        help="Generate scenario configs from secrets"
    )
    parser_apply.set_defaults(func=cmd_apply)

    args = parser.parse_args()

    # Execute the command
    exit_code = args.func(args)
    sys.exit(exit_code)


if __name__ == "__main__":
    main()

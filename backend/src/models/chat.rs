use crate::db::entity::messages;
use crate::db::entity_ext::chats;
use crate::db::entity_ext::chats_latest_message;
use crate::db::entity_ext::prelude::*;
use crate::models::message::GenerationParameters;
use crate::models::pagination;
use crate::policy::prelude::*;
use eyre::{eyre, Report};
use sea_orm::prelude::*;
use sea_orm::{
    ActiveValue, DatabaseConnection, EntityTrait, FromQueryResult, QueryOrder, QuerySelect,
};
use sqlx::types::chrono::Utc;

/// Indicates whether a chat was newly created or already existed
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChatCreationStatus {
    /// The chat was newly created
    Created,
    /// The chat already existed
    Existing,
}

impl From<&chats::Model> for Resource {
    fn from(val: &chats::Model) -> Self {
        Resource::Chat(val.id.as_hyphenated().to_string())
    }
}

/// If `existing_chat_id` is provided, try to load the chat from the database.
/// If the chat is not found, an error is returned.
/// If `existing_chat_id` is not provided, create a new chat, with `owner_user_id` as the owner.
///
/// Returns a tuple of (chat model, creation status) where the status indicates whether
/// the chat was newly created or already existed.
pub async fn get_or_create_chat(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    existing_chat_id: Option<&Uuid>,
    owner_user_id: &str,
) -> Result<(chats::Model, ChatCreationStatus), Report> {
    if let Some(existing_chat_id) = existing_chat_id {
        let existing_chat: Option<chats::Model> =
            Chats::find_by_id(*existing_chat_id).one(conn).await?;
        // Return with error if the chat is not found
        let existing_chat = existing_chat.ok_or(eyre!("Chat {existing_chat_id} not found"))?;
        // Authorize the user to access the chat
        authorize!(policy, subject, &existing_chat, Action::Read)?;
        Ok((existing_chat, ChatCreationStatus::Existing))
    } else {
        // Authorize that user is allowed to create a chat
        authorize!(policy, subject, &Resource::ChatSingleton, Action::Create)?;
        let new_chat = chats::ActiveModel {
            owner_user_id: ActiveValue::Set(owner_user_id.to_owned()),
            ..Default::default()
        };
        let created_chat = chats::Entity::insert(new_chat)
            .exec_with_returning(conn)
            .await?;
        Ok((created_chat, ChatCreationStatus::Created))
    }
}

/// Get all chats from the database.
pub async fn get_all_chats(conn: &DatabaseConnection) -> Result<Vec<chats::Model>, Report> {
    Ok(Chats::find().all(conn).await?)
}

/// Convenience method to get or create a chat based on a previous message ID.
///
/// If the message ID is provided, it will find the chat that the message belongs to.
/// If the message ID is not provided, it will create a new chat.
///
/// Returns a tuple of (chat model, creation status) where the status indicates whether
/// the chat was newly created or already existed.
pub async fn get_or_create_chat_by_previous_message_id(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    previous_message_id: Option<&Uuid>,
    owner_user_id: &str,
) -> Result<(chats::Model, ChatCreationStatus), Report> {
    if let Some(message_id) = previous_message_id {
        // Find the message to get its chat_id
        let message = Messages::find_by_id(*message_id)
            .one(conn)
            .await?
            .ok_or_else(|| eyre!("Message with ID {} not found", message_id))?;

        // Use the chat_id from the message with get_or_create_chat
        get_or_create_chat(conn, policy, subject, Some(&message.chat_id), owner_user_id).await
    } else {
        // No previous message ID, so create a new chat using get_or_create_chat
        get_or_create_chat(conn, policy, subject, None, owner_user_id).await
    }
}

#[derive(Debug, FromQueryResult)]
pub struct RecentChat {
    pub id: String,
    /// Title of the chat, as generated by a summary of the chat.
    pub title_by_summary: String,
    /// Time of the last message in the chat.
    pub last_message_at: DateTimeWithTimeZone,
    pub archived_at: Option<DateTimeWithTimeZone>,
    /// The chat provider ID used for the most recent message
    pub last_chat_provider_id: Option<String>,
}

/// Statistics for a list of chats
#[derive(Debug, Clone)]
pub struct ChatListStats {
    /// Total number of chats available
    pub total_count: i64,
    /// Current offset in the list
    pub current_offset: u64,
    /// Number of chats in the current response
    pub returned_count: usize,
    /// Whether there are more chats available
    pub has_more: bool,
}

/// Get the most recent chats for a user.
///
/// Returns a tuple of (chats, stats) where:
/// - chats: Vec<RecentChat> - The list of recent chats
/// - stats: ChatListStats - Statistics about the chat list
pub async fn get_recent_chats(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    owner_user_id: &str,
    limit: u64,
    offset: u64,
    include_archived: bool,
) -> Result<(Vec<RecentChat>, ChatListStats), Report> {
    // Query the most recent chats for the user.
    // Query the chats belongin to a user, and join with the chats_latest_message view.
    let mut query = Chats::find()
        .filter(chats::Column::OwnerUserId.eq(owner_user_id))
        .find_also_related(chats_latest_message::Entity)
        .filter(chats_latest_message::Column::LatestMessageId.is_not_null());

    // Filter out archived chats if include_archived is false
    if !include_archived {
        query = query.filter(chats::Column::ArchivedAt.is_null());
    }

    let chats: Vec<(chats::Model, Option<chats_latest_message::Model>)> = query
        .order_by_desc(chats_latest_message::Column::LatestMessageAt)
        .limit(limit)
        .offset(offset)
        .all(conn)
        .await?;

    // Use our pagination utility to efficiently calculate the total count
    let (total_count, has_more) =
        pagination::calculate_total_count(offset, limit, chats.len(), || async {
            let mut count_query = Chats::find()
                .filter(chats::Column::OwnerUserId.eq(owner_user_id))
                .find_also_related(chats_latest_message::Entity)
                .filter(chats_latest_message::Column::LatestMessageId.is_not_null());

            // Apply same archived filter to count query
            if !include_archived {
                count_query = count_query.filter(chats::Column::ArchivedAt.is_null());
            }

            count_query.count(conn).await
        })
        .await?;

    // Should already be filtered to the correct user, but make sure to authorize.
    let mut authorized_chats = Vec::new();
    for (chat, latest_message) in chats.iter() {
        if authorize!(
            policy,
            subject,
            &Resource::Chat(chat.id.to_string()),
            Action::Read
        )
        .is_ok()
        {
            authorized_chats.push((chat, latest_message));
        }
    }

    // Collect recent chats with last chat provider IDs
    let mut recent_chats = Vec::new();
    for (chat, latest_message) in authorized_chats.iter() {
        let latest_message = latest_message
            .as_ref()
            .expect("Latest message should never be None");

        // Get the last chat provider ID for this chat
        let last_chat_provider_id = get_last_chat_provider_id(conn, &chat.id)
            .await
            .unwrap_or(None);

        recent_chats.push(RecentChat {
            id: chat.id.to_string(),
            // Use the chat's title_by_summary if available, otherwise use a default
            title_by_summary: chat
                .title_by_summary
                .clone()
                .unwrap_or_else(|| "Untitled Chat".to_string()),
            last_message_at: latest_message.latest_message_at,
            archived_at: chat.archived_at,
            last_chat_provider_id,
        });
    }

    // Create the statistics object
    let stats = ChatListStats {
        total_count: pagination::u64_to_i64_count(total_count),
        current_offset: offset,
        returned_count: recent_chats.len(),
        has_more,
    };

    Ok((recent_chats, stats))
}

pub async fn get_chat_by_message_id(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    message_id: &Uuid,
) -> Result<chats::Model, Report> {
    // Find the message to get its chat_id
    let message = Messages::find_by_id(*message_id)
        .one(conn)
        .await?
        .ok_or_else(|| eyre!("Message with ID {} not found", message_id))?;

    // Find the chat
    let chat = Chats::find_by_id(message.chat_id)
        .one(conn)
        .await?
        .ok_or_else(|| eyre!("Chat with ID {} not found", message.chat_id))?;

    // Authorize that the subject can read this chat
    authorize!(
        policy,
        subject,
        &Resource::Chat(chat.id.to_string()),
        Action::Read
    )?;

    Ok(chat)
}

/// Update the title_by_summary field of a chat
pub async fn update_chat_summary(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    chat_id: &Uuid,
    summary: String,
) -> Result<chats::Model, Report> {
    // Find the chat
    let chat = Chats::find_by_id(*chat_id)
        .one(conn)
        .await?
        .ok_or_else(|| eyre!("Chat with ID {} not found", chat_id))?;

    // Authorize the user to update the chat
    authorize!(
        policy,
        subject,
        &Resource::Chat(chat.id.to_string()),
        Action::Update
    )?;

    // Update the chat
    let mut chat_active: chats::ActiveModel = chat.clone().into();
    chat_active.title_by_summary = ActiveValue::Set(Some(summary));

    let updated_chat = chat_active.update(conn).await?;

    Ok(updated_chat)
}

/// Archive a chat by setting its archived_at timestamp
pub async fn archive_chat(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    chat_id: &Uuid,
) -> Result<chats::Model, Report> {
    // Find the chat
    let chat = Chats::find_by_id(*chat_id)
        .one(conn)
        .await?
        .ok_or_else(|| eyre!("Chat with ID {} not found", chat_id))?;

    // Authorize the user to update the chat
    authorize!(
        policy,
        subject,
        &Resource::Chat(chat.id.to_string()),
        Action::Update
    )?;

    // Update the chat
    let mut chat_active: chats::ActiveModel = chat.clone().into();
    chat_active.archived_at = ActiveValue::Set(Some(Utc::now().into()));

    let updated_chat = chat_active.update(conn).await?;

    Ok(updated_chat)
}

/// Get the chat provider ID from the most recent active message in a chat.
/// Returns None if no active messages found or if the message doesn't have generation parameters.
pub async fn get_last_chat_provider_id(
    conn: &DatabaseConnection,
    chat_id: &Uuid,
) -> Result<Option<String>, Report> {
    // Find the most recent active message in the chat that has generation_parameters
    let message = Messages::find()
        .filter(messages::Column::ChatId.eq(*chat_id))
        .filter(messages::Column::IsMessageInActiveThread.eq(true))
        .filter(messages::Column::GenerationParameters.is_not_null())
        .order_by_desc(messages::Column::CreatedAt)
        .one(conn)
        .await?;

    if let Some(message) = message {
        if let Some(generation_params_json) = message.generation_parameters {
            // Parse the generation_parameters JSON
            let generation_params: GenerationParameters =
                serde_json::from_value(generation_params_json).map_err(|e| {
                    eyre!(
                        "Failed to parse generation parameters for message {}: {}",
                        message.id,
                        e
                    )
                })?;

            return Ok(generation_params.generation_chat_provider_id);
        }
    }

    Ok(None)
}

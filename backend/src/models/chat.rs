use crate::db::entity_ext::chats;
use crate::db::entity_ext::chats_latest_message;
use crate::db::entity_ext::prelude::*;
use crate::policy::prelude::*;
use eyre::{eyre, Report};
use sea_orm::prelude::*;
use sea_orm::{ActiveValue, DatabaseConnection, EntityTrait, FromQueryResult, QuerySelect};

/// Indicates whether a chat was newly created or already existed
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ChatCreationStatus {
    /// The chat was newly created
    Created,
    /// The chat already existed
    Existing,
}

impl From<&chats::Model> for Resource {
    fn from(val: &chats::Model) -> Self {
        Resource::Chat(val.id.as_hyphenated().to_string())
    }
}

/// If `existing_chat_id` is provided, try to load the chat from the database.
/// If the chat is not found, an error is returned.
/// If `existing_chat_id` is not provided, create a new chat, with `owner_user_id` as the owner.
///
/// Returns a tuple of (chat model, creation status) where the status indicates whether
/// the chat was newly created or already existed.
pub async fn get_or_create_chat(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    existing_chat_id: Option<&Uuid>,
    owner_user_id: &str,
) -> Result<(chats::Model, ChatCreationStatus), Report> {
    if let Some(existing_chat_id) = existing_chat_id {
        let existing_chat: Option<chats::Model> =
            Chats::find_by_id(*existing_chat_id).one(conn).await?;
        // Return with error if the chat is not found
        let existing_chat = existing_chat.ok_or(eyre!("Chat {existing_chat_id} not found"))?;
        // Authorize the user to access the chat
        authorize!(policy, subject, &existing_chat, Action::Read)?;
        Ok((existing_chat, ChatCreationStatus::Existing))
    } else {
        // Authorize that user is allowed to create a chat
        authorize!(policy, subject, &Resource::ChatSingleton, Action::Create)?;
        let new_chat = chats::ActiveModel {
            owner_user_id: ActiveValue::Set(owner_user_id.to_owned()),
            ..Default::default()
        };
        let created_chat = chats::Entity::insert(new_chat)
            .exec_with_returning(conn)
            .await?;
        Ok((created_chat, ChatCreationStatus::Created))
    }
}

/// Convenience method to get or create a chat based on a previous message ID.
///
/// If the message ID is provided, it will find the chat that the message belongs to.
/// If the message ID is not provided, it will create a new chat.
///
/// Returns a tuple of (chat model, creation status) where the status indicates whether
/// the chat was newly created or already existed.
pub async fn get_or_create_chat_by_previous_message_id(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    previous_message_id: Option<&Uuid>,
    owner_user_id: &str,
) -> Result<(chats::Model, ChatCreationStatus), Report> {
    if let Some(message_id) = previous_message_id {
        // Find the message to get its chat_id
        let message = Messages::find_by_id(*message_id)
            .one(conn)
            .await?
            .ok_or_else(|| eyre!("Message with ID {} not found", message_id))?;

        // Use the chat_id from the message with get_or_create_chat
        get_or_create_chat(conn, policy, subject, Some(&message.chat_id), owner_user_id).await
    } else {
        // No previous message ID, so create a new chat using get_or_create_chat
        get_or_create_chat(conn, policy, subject, None, owner_user_id).await
    }
}

#[derive(Debug, FromQueryResult)]
pub struct RecentChat {
    pub id: String,
    /// Title of the chat, as generated by a summary of the chat.
    pub title_by_summary: String,
    /// Time of the last message in the chat.
    pub last_message_at: DateTimeWithTimeZone,
}

/// Get the most recent chats for a user.
///
/// Returns a compact form of the chat, suitable for usage in e.g. displaying in the sidebar of a UI.
pub async fn get_recent_chats(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    owner_user_id: &str,
    limit: u64,
    offset: u64,
) -> Result<Vec<RecentChat>, Report> {
    // Query the most recent chats for the user.
    // Query the chats belongin to a user, and join with the chats_latest_message view.
    let chats: Vec<(chats::Model, Option<chats_latest_message::Model>)> = Chats::find()
        .filter(chats::Column::OwnerUserId.eq(owner_user_id))
        .find_also_related(chats_latest_message::Entity)
        .filter(chats_latest_message::Column::LatestMessageId.is_not_null())
        .limit(limit)
        .offset(offset)
        .all(conn)
        .await?;

    // Should already be filtered to the correct user, but make sure to authorize.
    let authorized_chats: Vec<_> = chats
        .iter()
        .filter(|(chat, _)| {
            authorize!(
                policy,
                subject,
                &Resource::Chat(chat.id.to_string()),
                Action::Read
            )
            .is_ok()
        })
        .collect();

    let recent_chats = authorized_chats
        .iter()
        .map(|(chat, latest_message)| {
            let latest_message = latest_message
                .as_ref()
                .expect("Latest message should never be None");
            RecentChat {
                id: chat.id.to_string(),
                // Use the chat's title_by_summary if available, otherwise use a default
                title_by_summary: chat
                    .title_by_summary
                    .clone()
                    .unwrap_or_else(|| "Untitled Chat".to_string()),
                last_message_at: latest_message.latest_message_at,
            }
        })
        .collect();
    Ok(recent_chats)
}

pub async fn get_chat_by_message_id(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    message_id: &Uuid,
) -> Result<chats::Model, Report> {
    // Find the message to get its chat_id
    let message = Messages::find_by_id(*message_id)
        .one(conn)
        .await?
        .ok_or_else(|| eyre!("Message with ID {} not found", message_id))?;

    // Find the chat
    let chat = Chats::find_by_id(message.chat_id)
        .one(conn)
        .await?
        .ok_or_else(|| eyre!("Chat with ID {} not found", message.chat_id))?;

    // Authorize that the subject can read this chat
    authorize!(
        policy,
        subject,
        &Resource::Chat(chat.id.to_string()),
        Action::Read
    )?;

    Ok(chat)
}

/// Update the title_by_summary field of a chat
pub async fn update_chat_summary(
    conn: &DatabaseConnection,
    policy: &PolicyEngine,
    subject: &Subject,
    chat_id: &Uuid,
    summary: String,
) -> Result<chats::Model, Report> {
    // Find the chat
    let chat = Chats::find_by_id(*chat_id)
        .one(conn)
        .await?
        .ok_or_else(|| eyre!("Chat with ID {} not found", chat_id))?;

    // Authorize the user to update the chat
    authorize!(
        policy,
        subject,
        &Resource::Chat(chat.id.to_string()),
        Action::Update
    )?;

    // Update the chat
    let mut chat_active: chats::ActiveModel = chat.clone().into();
    chat_active.title_by_summary = ActiveValue::Set(Some(summary));

    let updated_chat = chat_active.update(conn).await?;

    Ok(updated_chat)
}

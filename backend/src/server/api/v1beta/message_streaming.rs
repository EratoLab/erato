use crate::db::entity_ext::{chats, messages};
use crate::models::chat::{
    get_chat_by_message_id, get_or_create_chat_by_previous_message_id, ChatCreationStatus,
};
use crate::models::message::{
    get_generation_input_messages_by_previous_message_id, get_message_by_id, submit_message,
    GenerationInputMessages, MessageSchema,
};
use crate::server::api::v1beta::me_profile_middleware::MeProfile;
use crate::server::api::v1beta::ChatMessage;
use crate::state::AppState;
use axum::extract::State;
use axum::response::sse::Event;
use axum::response::Sse;
use axum::{Extension, Json};
use eyre::WrapErr;
use eyre::{eyre, Report};
use futures::Stream;
use genai::chat::{
    ChatMessage as GenAiChatMessage, ChatOptions, ChatRequest, ChatStreamEvent, StreamEnd,
};
use sea_orm::prelude::Uuid;
use sentry::{event_from_error, Hub};
use serde::Serialize;
use serde_json::json;
use std::error::Error;
use std::time::Duration;
use tokio::sync::mpsc::Sender;
use tokio_stream::StreamExt as _;
use utoipa::ToSchema;

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseChatCreated {
    chat_id: Uuid,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseUserMessageSaved {
    message_id: Uuid,
    message: ChatMessage,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseMessageComplete {
    message_id: Uuid,
    full_text: String,
    message: ChatMessage,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseMessageTextDelta {
    new_text: String,
}

trait SendAsSseEvent {
    fn tag(&self) -> &'static str;
    fn data_json(&self) -> Result<String, Report>;

    async fn send_event(&self, tx: Sender<Result<Event, Report>>) -> Result<(), ()> {
        match self.data_json() {
            Ok(json) => {
                if let Err(err) = tx
                    .send(Ok(Event::default().event(self.tag()).data(json)))
                    .await
                {
                    let _ = tx
                        .send(Err(eyre!(
                            "Failed to send {tag} event: {}",
                            err,
                            tag = self.tag()
                        )))
                        .await;
                    return Err(());
                }
            }
            Err(err) => {
                let _ = tx
                    .send(Err(eyre!(
                        "Failed to serialize {tag} event: {}",
                        err,
                        tag = self.tag()
                    )))
                    .await;
                return Err(());
            }
        }
        Ok(())
    }
}

#[derive(serde::Deserialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitRequest {
    #[schema(example = "00000000-0000-0000-0000-000000000000")]
    /// The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
    previous_message_id: Option<Uuid>,
    #[schema(example = "Hello, world!")]
    /// The text of the message.
    #[allow(dead_code)]
    user_message: String,
}

#[derive(Serialize, ToSchema)]
#[serde(tag = "message_type")]
pub enum MessageSubmitStreamingResponseMessage {
    #[serde(rename = "chat_created")]
    /// May optionally be sent at the start of the stream to indicate that a new chat has been created.
    ChatCreated(MessageSubmitStreamingResponseChatCreated),
    #[serde(rename = "user_message_saved")]
    /// Sent at the start of the stream to indicate that the user's message has been saved.
    UserMessageSaved(MessageSubmitStreamingResponseUserMessageSaved),
    #[serde(rename = "message_complete")]
    /// Sent when the assistant's response has been saved in full.
    MessageComplete(MessageSubmitStreamingResponseMessageComplete),
    #[serde(rename = "text_delta")]
    /// Sent whenever a new text chunk is generated by the assistant.
    TextDelta(MessageSubmitStreamingResponseMessageTextDelta),
}

impl SendAsSseEvent for MessageSubmitStreamingResponseMessage {
    fn tag(&self) -> &'static str {
        match self {
            Self::ChatCreated(_) => "chat_created",
            Self::UserMessageSaved(_) => "user_message_saved",
            Self::MessageComplete(_) => "message_complete",
            Self::TextDelta(_) => "text_delta",
        }
    }

    fn data_json(&self) -> Result<String, Report> {
        Ok(serde_json::to_string(self)?)
    }
}

impl From<MessageSubmitStreamingResponseChatCreated> for MessageSubmitStreamingResponseMessage {
    fn from(value: MessageSubmitStreamingResponseChatCreated) -> Self {
        MessageSubmitStreamingResponseMessage::ChatCreated(value)
    }
}

impl From<MessageSubmitStreamingResponseUserMessageSaved>
    for MessageSubmitStreamingResponseMessage
{
    fn from(value: MessageSubmitStreamingResponseUserMessageSaved) -> Self {
        MessageSubmitStreamingResponseMessage::UserMessageSaved(value)
    }
}

impl From<MessageSubmitStreamingResponseMessageComplete> for MessageSubmitStreamingResponseMessage {
    fn from(value: MessageSubmitStreamingResponseMessageComplete) -> Self {
        MessageSubmitStreamingResponseMessage::MessageComplete(value)
    }
}

impl From<MessageSubmitStreamingResponseMessageTextDelta>
    for MessageSubmitStreamingResponseMessage
{
    fn from(value: MessageSubmitStreamingResponseMessageTextDelta) -> Self {
        MessageSubmitStreamingResponseMessage::TextDelta(value)
    }
}

#[derive(serde::Deserialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct RegenerateMessageRequest {
    #[schema(example = "00000000-0000-0000-0000-000000000000")]
    /// The ID of the message that should have a replacement response generated.
    current_message_id: Uuid,
}

#[derive(Serialize, ToSchema)]
#[serde(tag = "message_type")]
pub enum RegenerateMessageStreamingResponseMessage {
    #[serde(rename = "message_complete")]
    /// Sent when the assistant's response has been saved in full.
    MessageComplete(MessageSubmitStreamingResponseMessageComplete),
    #[serde(rename = "text_delta")]
    /// Sent whenever a new text chunk is generated by the assistant.
    TextDelta(MessageSubmitStreamingResponseMessageTextDelta),
}

impl SendAsSseEvent for RegenerateMessageStreamingResponseMessage {
    fn tag(&self) -> &'static str {
        match self {
            Self::MessageComplete(_) => "message_complete",
            Self::TextDelta(_) => "text_delta",
        }
    }

    fn data_json(&self) -> Result<String, Report> {
        Ok(serde_json::to_string(self)?)
    }
}

impl From<MessageSubmitStreamingResponseMessageComplete>
    for RegenerateMessageStreamingResponseMessage
{
    fn from(value: MessageSubmitStreamingResponseMessageComplete) -> Self {
        RegenerateMessageStreamingResponseMessage::MessageComplete(value)
    }
}

impl From<MessageSubmitStreamingResponseMessageTextDelta>
    for RegenerateMessageStreamingResponseMessage
{
    fn from(value: MessageSubmitStreamingResponseMessageTextDelta) -> Self {
        RegenerateMessageStreamingResponseMessage::TextDelta(value)
    }
}

async fn stream_get_or_create_chat<
    MSG: SendAsSseEvent + From<MessageSubmitStreamingResponseChatCreated>,
>(
    tx: Sender<Result<Event, Report>>,
    app_state: &AppState,
    me_user: &MeProfile,
    previous_message_id: Option<&Uuid>,
) -> Result<(chats::Model, ChatCreationStatus), ()> {
    // Get or create the chat using the previous message ID
    let result = get_or_create_chat_by_previous_message_id(
        &app_state.db,
        app_state.policy(),
        &me_user.to_subject(),
        previous_message_id,
        &me_user.0.id,
    )
    .await;

    // Send chat created event if the chat was newly created
    match result {
        Ok((chat, chat_status)) => {
            if chat_status == ChatCreationStatus::Created {
                let inner_msg = MessageSubmitStreamingResponseChatCreated { chat_id: chat.id };
                let chat_created: MSG = inner_msg.into();
                chat_created.send_event(tx.clone()).await?;
            }
            Ok((chat, chat_status))
        }
        Err(err) => {
            let _ = tx
                .send(Err(err).wrap_err("Failed to get or create chat"))
                .await;
            Err(())
        }
    }
}

async fn stream_save_user_message<
    MSG: SendAsSseEvent + From<MessageSubmitStreamingResponseUserMessageSaved>,
>(
    tx: Sender<Result<Event, Report>>,
    app_state: &AppState,
    me_user: &MeProfile,
    chat: &chats::Model,
    previous_message_id: Option<&Uuid>,
    user_message: &str,
) -> Result<messages::Model, ()> {
    // Create and save the user's message
    let user_message = json!({
        "role": "user",
        "content": user_message.to_owned(),
        "name": me_user.0.id
    });

    let saved_user_message = match submit_message(
        &app_state.db,
        app_state.policy(),
        &me_user.to_subject(),
        &chat.id,
        user_message,
        previous_message_id,
        // TODO: Add support for sibling message regenerate
        None,
        None,
    )
    .await
    {
        Ok(msg) => msg,
        Err(err) => {
            let _ = tx
                .send(Err(err).wrap_err("Failed to submit user message"))
                .await;
            return Err(());
        }
    };

    let saved_user_message_wrapped = match ChatMessage::from_model(saved_user_message.clone()) {
        Ok(msg) => msg,
        Err(err) => {
            let _ = tx
                .send(Err(err).wrap_err("Failed to submit user message"))
                .await;
            return Err(());
        }
    };

    // Send user message saved event
    let user_message_saved: MSG = MessageSubmitStreamingResponseUserMessageSaved {
        message_id: saved_user_message.id,
        message: saved_user_message_wrapped,
    }
    .into();
    user_message_saved.send_event(tx.clone()).await?;
    Ok(saved_user_message)
}

async fn prepare_chat_request(
    app_state: &AppState,
    previous_message_id: &Uuid,
) -> Result<(ChatRequest, ChatOptions, GenerationInputMessages), Report> {
    // TODO: Initial system message?
    let generation_input_messages = get_generation_input_messages_by_previous_message_id(
        &app_state.db,
        previous_message_id,
        Some(10),
    )
    .await?;
    let chat_request = generation_input_messages.clone().into_chat_request();
    let chat_options = ChatOptions::default().with_capture_content(true);

    Ok((chat_request, chat_options, generation_input_messages))
}

async fn stream_generate_chat_completion<
    MSG: SendAsSseEvent + From<MessageSubmitStreamingResponseMessageTextDelta>,
>(
    tx: Sender<Result<Event, Report>>,
    app_state: &AppState,
    chat_request: ChatRequest,
    chat_options: ChatOptions,
) -> Result<StreamEnd, ()> {
    let chat_stream = match app_state
        .genai()
        .exec_chat_stream("PLACEHOLDER_MODEL", chat_request, Some(&chat_options))
        .await
    {
        Ok(stream) => stream,
        Err(err) => {
            let _ = tx
                .send(Err(err).wrap_err("Failed to start chat stream with LLM provider"))
                .await;
            return Err(());
        }
    };

    let mut inner_stream = chat_stream.stream;
    // Await until stream end
    let mut stream_end: Option<StreamEnd> = None;
    while let Some(result) = inner_stream.next().await {
        match result {
            Ok(message) => match message {
                ChatStreamEvent::Chunk(chunk) => {
                    let delta = MessageSubmitStreamingResponseMessageTextDelta {
                        new_text: chunk.content,
                    };
                    let message: MSG = delta.into();
                    message.send_event(tx.clone()).await?;
                }
                ChatStreamEvent::End(end) => {
                    stream_end = Some(end);
                }
                _ => {}
            },
            Err(err) => {
                let _ = tx.send(Err(err).wrap_err("Error from chat stream")).await;
                return Err(());
            }
        }
    }
    if let Some(stream_end) = stream_end {
        Ok(stream_end)
    } else {
        // TODO: Send error that stream ended without sending stream_end event
        Err(())
    }
}

#[allow(clippy::too_many_arguments)]
async fn stream_save_generated_completion<
    MSG: SendAsSseEvent + From<MessageSubmitStreamingResponseMessageComplete>,
>(
    tx: Sender<Result<Event, Report>>,
    app_state: &AppState,
    end: StreamEnd,
    me_user: &MeProfile,
    chat: &chats::Model,
    saved_user_message: &messages::Model,
    sibling_message_id: Option<&Uuid>,
    generation_input_messages: GenerationInputMessages,
) -> Result<(), ()> {
    let final_content = match end
        .captured_content
        .ok_or_else(|| eyre!("No captured content in chat stream end event"))
        .map(|content| content.text_into_string().expect("Expected text response"))
    {
        Ok(content) => content,
        Err(err) => {
            let _ = tx.send(Err(err)).await;
            return Err(());
        }
    };

    let assistant_message = json!({
        "role": "assistant",
        "content": final_content.clone(),
    });

    let saved_assistant_message = match submit_message(
        &app_state.db,
        app_state.policy(),
        &me_user.to_subject(),
        &chat.id,
        assistant_message.clone(),
        Some(&saved_user_message.id),
        sibling_message_id,
        Some(generation_input_messages),
    )
    .await
    {
        Ok(msg) => msg,
        Err(err) => {
            let _ = tx
                .send(Err(err).wrap_err("Failed to submit assistant message"))
                .await;
            return Err(());
        }
    };

    let saved_assistant_message_wrapped =
        match ChatMessage::from_model(saved_assistant_message.clone()) {
            Ok(msg) => msg,
            Err(err) => {
                let _ = tx
                    .send(Err(err).wrap_err("Failed to convert saved assistant message"))
                    .await;
                return Err(());
            }
        };

    let message_complete: MSG = MessageSubmitStreamingResponseMessageComplete {
        message_id: saved_assistant_message.id,
        full_text: final_content.clone(),
        message: saved_assistant_message_wrapped,
    }
    .into();
    message_complete.send_event(tx.clone()).await?;

    Ok(())
}

/// Generate a summary of the chat, based on the first message to the chat.
pub async fn generate_chat_summary(
    app_state: &AppState,
    me_user: &MeProfile,
    chat: &chats::Model,
    first_message: &messages::Model,
) -> Result<(), Report> {
    let first_message_content = MessageSchema::validate(&first_message.raw_message)?;
    let first_message_content_text = first_message_content.full_text();

    let prompt = format!(
        "Generate a summary for the topic of the following chat, based on the first message to the chat. The summary should be a short single sentence description like e.g. `Regex Search-and-Replace with Ripgrep` or `Explain a customer support flow`. Only return that sentence and nothing else. The chat message : {}",
        first_message_content_text
    );

    let mut chat_request: ChatRequest = Default::default();
    chat_request = chat_request.append_message(GenAiChatMessage::user(prompt));
    let chat_options = ChatOptions::default()
        .with_capture_content(true)
        .with_max_tokens(30);

    let summary_completion = app_state
        .genai()
        .exec_chat("PLACEHOLDER_MODEL", chat_request, Some(&chat_options))
        .await?;

    let summary = summary_completion
        .content
        .ok_or_else(|| eyre!("No captured content in chat stream end event"))?
        .text_into_string()
        .ok_or_else(|| eyre!("Expected text response"))?;

    // Update the chat with the generated summary
    crate::models::chat::update_chat_summary(
        &app_state.db,
        &app_state.policy,
        &me_user.to_subject(),
        &chat.id,
        summary,
    )
    .await
    .wrap_err("Failed to update chat summary")?;

    Ok(())
}

#[utoipa::path(
    post,
    path = "/me/messages/submitstream",
    request_body = MessageSubmitRequest,
    responses(
        (status = OK, content_type="text/event-stream", body = MessageSubmitStreamingResponseMessage),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided"),
        (status = INTERNAL_SERVER_ERROR, description = "When an internal server error occurs")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn message_submit_sse(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    Json(request): Json<MessageSubmitRequest>,
) -> Sse<impl Stream<Item = Result<Event, Report>>> {
    // Create a channel for sending events
    let (tx, rx) = tokio::sync::mpsc::channel::<Result<Event, Report>>(100);

    // Spawn a task to process the request and send events
    tokio::spawn(async move {
        let (chat, chat_status) =
            stream_get_or_create_chat::<MessageSubmitStreamingResponseMessage>(
                tx.clone(),
                &app_state,
                &me_user,
                request.previous_message_id.as_ref(),
            )
            .await?;

        let saved_user_message = stream_save_user_message::<MessageSubmitStreamingResponseMessage>(
            tx.clone(),
            &app_state,
            &me_user,
            &chat,
            request.previous_message_id.as_ref(),
            &request.user_message,
        )
        .await?;

        if chat_status == ChatCreationStatus::Created {
            let app_state_clone = app_state.clone();
            let me_user_clone = me_user.clone();
            let chat_clone = chat.clone();
            let saved_user_message_clone = saved_user_message.clone();
            tokio::spawn(async move {
                generate_chat_summary(
                    &app_state_clone,
                    &me_user_clone,
                    &chat_clone,
                    &saved_user_message_clone,
                )
                .await?;
                Ok::<(), Report>(())
            });
        }

        let prepare_chat_request_res =
            prepare_chat_request(&app_state, &saved_user_message.id).await;
        if let Err(err) = prepare_chat_request_res {
            let _ = tx.send(Err(err)).await;
            return Err(());
        }
        let (chat_request, chat_options, generation_input_messages) =
            prepare_chat_request_res.unwrap();

        let end = stream_generate_chat_completion::<MessageSubmitStreamingResponseMessage>(
            tx.clone(),
            &app_state,
            chat_request,
            chat_options,
        )
        .await?;

        stream_save_generated_completion::<MessageSubmitStreamingResponseMessage>(
            tx.clone(),
            &app_state,
            end,
            &me_user,
            &chat,
            &saved_user_message,
            None,
            generation_input_messages,
        )
        .await?;

        Ok::<(), ()>(())
    });

    // Convert the receiver into a stream and return it
    let receiver_stream = tokio_stream::wrappers::ReceiverStream::<Result<Event, Report>>::new(rx);
    let inspected_stream = futures::StreamExt::inspect(receiver_stream, |event| {
        if let Err(err) = event {
            capture_report(err);
        }
    });

    Sse::new(inspected_stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(1))
            .text("keep-alive-text"),
    )
}

#[utoipa::path(
    post,
    path = "/me/messages/regeneratestream",
    request_body = RegenerateMessageRequest,
    responses(
        (status = OK, content_type="text/event-stream", body = RegenerateMessageStreamingResponseMessage),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided"),
        (status = INTERNAL_SERVER_ERROR, description = "When an internal server error occurs")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn regenerate_message_sse(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    Json(request): Json<RegenerateMessageRequest>,
) -> Sse<impl Stream<Item = Result<Event, Report>>> {
    // Create a channel for sending events
    let (tx, rx) = tokio::sync::mpsc::channel::<Result<Event, Report>>(100);

    // Spawn a task to process the request and send events
    tokio::spawn(async move {
        // Get the current message in order to get previous message ID
        let current_message_res = get_message_by_id(
            &app_state.db,
            &app_state.policy,
            &me_user.to_subject(),
            &request.current_message_id,
        )
        .await;
        if let Err(err) = current_message_res {
            let _ = tx.send(Err(err)).await;
            return Err(());
        }
        let current_message = current_message_res.unwrap();
        // Verify that the current message is a assistant message
        // TODO: Parse raw_message and verify
        // if current_message.role != "assistant" {
        //     let _ = tx.send(Err(eyre!("Current message is not an assistant message"))).await;
        //     return Err(());
        // }

        // Get the previous message in order to get the chat + required message content
        let previous_message_res = get_message_by_id(
            &app_state.db,
            &app_state.policy,
            &me_user.to_subject(),
            &current_message
                .previous_message_id
                .expect("Expected previous message ID"),
        )
        .await;
        if let Err(err) = previous_message_res {
            let _ = tx.send(Err(err)).await;
            return Err(());
        }
        let previous_message = previous_message_res.unwrap();
        // Verify that the previous message is a user message
        // TODO: Parse raw_message and verify
        // if previous_message.role != "user" {
        //     let _ = tx.send(Err(eyre!("Previous message is not a user message"))).await;
        //     return Err(());
        // }

        let chat_res = get_chat_by_message_id(
            &app_state.db,
            &app_state.policy,
            &me_user.to_subject(),
            &request.current_message_id,
        )
        .await;
        if let Err(err) = chat_res {
            let _ = tx.send(Err(err)).await;
            return Err(());
        }
        let chat = chat_res.unwrap();

        let prepare_chat_request_res = prepare_chat_request(&app_state, &previous_message.id).await;
        if let Err(err) = prepare_chat_request_res {
            let _ = tx.send(Err(err)).await;
            return Err(());
        }
        let (chat_request, chat_options, generation_input_messages) =
            prepare_chat_request_res.unwrap();

        let end = stream_generate_chat_completion::<RegenerateMessageStreamingResponseMessage>(
            tx.clone(),
            &app_state,
            chat_request,
            chat_options,
        )
        .await?;

        stream_save_generated_completion::<RegenerateMessageStreamingResponseMessage>(
            tx.clone(),
            &app_state,
            end,
            &me_user,
            &chat,
            &previous_message,
            Some(&request.current_message_id),
            generation_input_messages,
        )
        .await?;

        Ok::<(), ()>(())
    });

    // Convert the receiver into a stream and return it
    let receiver_stream = tokio_stream::wrappers::ReceiverStream::<Result<Event, Report>>::new(rx);
    let inspected_stream = futures::StreamExt::inspect(receiver_stream, |event| {
        if let Err(err) = event {
            capture_report(err);
        }
    });

    Sse::new(inspected_stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(1))
            .text("keep-alive-text"),
    )
}

#[cfg(feature = "sentry")]
fn capture_report(report: &Report) {
    Hub::with_active(|hub| {
        let err: &dyn Error = report.as_ref();
        let event = event_from_error(err);
        // if let Some(exc) = event.exception.iter_mut().last() {
        //     let backtrace = err.backtrace();
        //     exc.stacktrace = sentry_backtrace::parse_stacktrace(&format!("{backtrace:#}"));
        // }

        hub.capture_event(event);
    });
}

#[cfg(not(feature = "sentry"))]
fn log_internal_server_error(err: &Report) {
    tracing::error!("{}", err.to_string());
}

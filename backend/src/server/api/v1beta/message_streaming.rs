use crate::models::chat::{get_or_create_chat_by_previous_message_id, ChatCreationStatus};
use crate::models::message::submit_message;
use crate::server::api::v1beta::me_profile_middleware::MeProfile;
use crate::server::api::v1beta::ChatMessage;
use crate::state::AppState;
use axum::extract::State;
use axum::response::sse::Event;
use axum::response::Sse;
use axum::{Extension, Json};
use eyre::{eyre, Report};
use futures::Stream;
use genai::chat::{ChatMessage as GenAiChatMessage, ChatOptions, ChatRequest, ChatStreamEvent};
use sea_orm::prelude::Uuid;
use serde::Serialize;
use serde_json::json;
use std::time::Duration;
use tokio_stream::StreamExt as _;
use utoipa::ToSchema;

#[derive(Serialize, ToSchema)]
#[serde(tag = "message_type")]
pub enum MessageSubmitStreamingResponseMessage {
    #[serde(rename = "chat_created")]
    /// May optionally be sent at the start of the stream to indicate that a new chat has been created.
    ChatCreated(MessageSubmitStreamingResponseChatCreated),
    #[serde(rename = "user_message_saved")]
    /// Sent at the start of the stream to indicate that the user's message has been saved.
    UserMessageSaved(MessageSubmitStreamingResponseUserMessageSaved),
    #[serde(rename = "message_complete")]
    /// Sent when the assistant's response has been saved in full.
    MessageComplete(MessageSubmitStreamingResponseMessageComplete),
    #[serde(rename = "text_delta")]
    /// Sent whenever a new text chunk is generated by the assistant.
    TextDelta(MessageSubmitStreamingResponseMessageTextDelta),
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseChatCreated {
    chat_id: Uuid,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseUserMessageSaved {
    message_id: Uuid,
    message: ChatMessage,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseMessageComplete {
    message_id: Uuid,
    full_text: String,
    message: ChatMessage,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitStreamingResponseMessageTextDelta {
    new_text: String,
}

#[derive(serde::Deserialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitRequest {
    #[schema(example = "00000000-0000-0000-0000-000000000000")]
    /// The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
    previous_message_id: Option<Uuid>,
    #[schema(example = "Hello, world!")]
    /// The text of the message.
    #[allow(dead_code)]
    user_message: String,
}

#[utoipa::path(
    post,
    path = "/me/messages/submitstream",
    request_body = MessageSubmitRequest,
    responses(
        (status = OK, content_type="text/event-stream", body = MessageSubmitStreamingResponseMessage),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided"),
        (status = INTERNAL_SERVER_ERROR, description = "When an internal server error occurs")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn message_submit_sse(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    Json(request): Json<MessageSubmitRequest>,
) -> Sse<impl Stream<Item = Result<Event, Report>>> {
    // Create a channel for sending events
    let (tx, rx) = tokio::sync::mpsc::channel::<Result<Event, Report>>(100);

    // Spawn a task to process the request and send events
    tokio::spawn(async move {
        // Get or create the chat using the previous message ID
        let result = get_or_create_chat_by_previous_message_id(
            &app_state.db,
            app_state.policy(),
            &me_user.to_subject(),
            request.previous_message_id.as_ref(),
            &me_user.0.id,
        )
        .await;

        match result {
            Ok((chat, chat_status)) => {
                // Send chat created event if the chat was newly created
                if chat_status == ChatCreationStatus::Created {
                    let chat_created = MessageSubmitStreamingResponseMessage::ChatCreated(
                        MessageSubmitStreamingResponseChatCreated { chat_id: chat.id },
                    );
                    match serde_json::to_string(&chat_created) {
                        Ok(json) => {
                            if let Err(err) = tx
                                .send(Ok(Event::default().event("chat_created").data(json)))
                                .await
                            {
                                let _ = tx
                                    .send(Err(eyre!("Failed to send chat_created event: {}", err)))
                                    .await;
                                return;
                            }
                        }
                        Err(err) => {
                            let _ = tx
                                .send(Err(eyre!(
                                    "Failed to serialize chat_created event: {}",
                                    err
                                )))
                                .await;
                            return;
                        }
                    }
                }

                // Create and save the user's message
                let user_message = json!({
                    "role": "user",
                    "content": request.user_message.clone(),
                    "name": me_user.0.id
                });

                let saved_user_message = match submit_message(
                    &app_state.db,
                    app_state.policy(),
                    &me_user.to_subject(),
                    &chat.id,
                    user_message,
                    request.previous_message_id.as_ref(),
                    // TODO: Add support for sibling message regenerate
                    None,
                    None,
                )
                .await
                {
                    Ok(msg) => msg,
                    Err(err) => {
                        let _ = tx
                            .send(Err(eyre!("Failed to submit user message: {}", err)))
                            .await;
                        return;
                    }
                };

                let saved_user_message_wrapped =
                    match ChatMessage::from_model(saved_user_message.clone()) {
                        Ok(msg) => msg,
                        Err(err) => {
                            let _ = tx
                                .send(Err(eyre!(
                                    "Failed to convert submitted user message: {}",
                                    err
                                )))
                                .await;
                            return;
                        }
                    };

                // Send user message saved event
                let user_message_saved = MessageSubmitStreamingResponseMessage::UserMessageSaved(
                    MessageSubmitStreamingResponseUserMessageSaved {
                        message_id: saved_user_message.id,
                        message: saved_user_message_wrapped,
                    },
                );
                match serde_json::to_string(&user_message_saved) {
                    Ok(json) => {
                        if let Err(err) = tx
                            .send(Ok(Event::default().event("user_message_saved").data(json)))
                            .await
                        {
                            let _ = tx
                                .send(Err(eyre!(
                                    "Failed to send user_message_saved event: {}",
                                    err
                                )))
                                .await;
                            return;
                        }
                    }
                    Err(err) => {
                        let _ = tx
                            .send(Err(eyre!(
                                "Failed to serialize user_message_saved event: {}",
                                err
                            )))
                            .await;
                        return;
                    }
                }

                let mut chat_request: ChatRequest = Default::default();
                // TODO: Initial system message?
                // TODO: Full previous message history
                chat_request =
                    chat_request.append_message(GenAiChatMessage::user(request.user_message));
                let chat_options = ChatOptions::default().with_capture_content(true);

                let chat_stream = match app_state
                    .genai()
                    .exec_chat_stream("foo_model", chat_request, Some(&chat_options))
                    .await
                {
                    Ok(stream) => stream,
                    Err(err) => {
                        let _ = tx
                            .send(Err(eyre!("Failed to execute chat stream: {}", err)))
                            .await;
                        return;
                    }
                };

                let mut inner_stream = chat_stream.stream;
                // Await until stream end
                while let Some(result) = inner_stream.next().await {
                    match result {
                        Ok(message) => {
                            match message {
                                ChatStreamEvent::Chunk(chunk) => {
                                    let delta = MessageSubmitStreamingResponseMessageTextDelta {
                                        new_text: chunk.content,
                                    };
                                    let message =
                                        MessageSubmitStreamingResponseMessage::TextDelta(delta);
                                    match serde_json::to_string(&message) {
                                        Ok(json) => {
                                            if let Err(err) = tx
                                                .send(Ok(Event::default()
                                                    .event("text_delta")
                                                    .data(json)))
                                                .await
                                            {
                                                let _ = tx
                                                    .send(Err(eyre!(
                                                        "Failed to send text_delta event: {}",
                                                        err
                                                    )))
                                                    .await;
                                                return;
                                            }
                                        }
                                        Err(err) => {
                                            let _ = tx
                                                .send(Err(eyre!(
                                                    "Failed to serialize text_delta event: {}",
                                                    err
                                                )))
                                                .await;
                                            return;
                                        }
                                    }
                                }
                                ChatStreamEvent::End(end) => {
                                    let final_content = match end
                                        .captured_content
                                        .ok_or_else(|| {
                                            eyre!("No captured content in chat stream end event")
                                        })
                                        .map(|content| {
                                            content
                                                .text_into_string()
                                                .expect("Expected text response")
                                        }) {
                                        Ok(content) => content,
                                        Err(err) => {
                                            let _ = tx.send(Err(err)).await;
                                            return;
                                        }
                                    };

                                    let assistant_message = json!({
                                        "role": "assistant",
                                        "content": final_content.clone(),
                                    });

                                    let saved_assistant_message = match submit_message(
                                        &app_state.db,
                                        app_state.policy(),
                                        &me_user.to_subject(),
                                        &chat.id,
                                        assistant_message.clone(),
                                        Some(&saved_user_message.id),
                                        None,
                                        // TODO: Save input messages here
                                        None,
                                    )
                                    .await
                                    {
                                        Ok(msg) => msg,
                                        Err(err) => {
                                            let _ = tx
                                                .send(Err(eyre!(
                                                    "Failed to submit assistant message: {}",
                                                    err
                                                )))
                                                .await;
                                            return;
                                        }
                                    };

                                    let saved_assistant_message_wrapped =
                                        match ChatMessage::from_model(
                                            saved_assistant_message.clone(),
                                        ) {
                                            Ok(msg) => msg,
                                            Err(err) => {
                                                let _ = tx
                                                    .send(Err(eyre!("Failed to convert saved assistant message: {}", err)))
                                                    .await;
                                                return;
                                            }
                                        };

                                    let message_complete =
                                        MessageSubmitStreamingResponseMessage::MessageComplete(
                                            MessageSubmitStreamingResponseMessageComplete {
                                                message_id: saved_assistant_message.id,
                                                full_text: final_content.clone(),
                                                message: saved_assistant_message_wrapped,
                                            },
                                        );
                                    match serde_json::to_string(&message_complete) {
                                        Ok(json) => {
                                            if let Err(err) = tx
                                                .send(Ok(Event::default()
                                                    .event("message_complete")
                                                    .data(json)))
                                                .await
                                            {
                                                let _ = tx
                                                    .send(Err(eyre!(
                                                        "Failed to send message_complete event: {}",
                                                        err
                                                    )))
                                                    .await;
                                                return;
                                            }
                                        }
                                        Err(err) => {
                                            let _ = tx.send(Err(eyre!("Failed to serialize message_complete event: {}", err))).await;
                                            return;
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        Err(err) => {
                            let _ = tx.send(Err(eyre!("Error from chat stream: {}", err))).await;
                            return;
                        }
                    }
                }
            }
            Err(err) => {
                let _ = tx
                    .send(Err(eyre!("Failed to get or create chat: {}", err)))
                    .await;
            }
        }
    });

    // Convert the receiver into a stream and return it
    let stream = tokio_stream::wrappers::ReceiverStream::new(rx);

    Sse::new(stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(1))
            .text("keep-alive-text"),
    )
}

pub mod me_profile_middleware;

use crate::models::chat::{get_or_create_chat, ChatCreationStatus};
use crate::models::message::submit_message;
use crate::server::api::v1beta::me_profile_middleware::{MeProfile, UserProfile};
use crate::state::AppState;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::sse::Event;
use axum::response::{IntoResponse, Sse};
use axum::routing::{get, post};
use axum::{middleware, Extension, Json, Router};
use futures::stream::Stream;
use genai::chat::{ChatMessage, ChatOptions, ChatRequest, ChatStreamEvent};
use serde::Serialize;
use serde_json::{self, json};
use sqlx::types::Uuid;
use std::convert::Infallible;
use std::time::Duration;
use tokio_stream::StreamExt as _;
use utoipa::{OpenApi, ToSchema};
use utoipa_axum::router::OpenApiRouter;

pub fn router(app_state: AppState) -> OpenApiRouter<AppState> {
    // build our application with a route
    let me_routes = Router::new()
        .route("/profile", get(profile))
        .route("/messages/submitstream", post(message_submit_sse))
        .route_layer(middleware::from_fn_with_state(
            app_state,
            me_profile_middleware::user_profile_middleware,
        ));

    let app = Router::new()
        .route("/messages", get(messages))
        .route("/chats", get(chats))
        .nest("/me", me_routes)
        .fallback(fallback);
    app.into()
}

#[derive(OpenApi)]
#[openapi(
    paths(messages, chats, message_submit_sse, profile),
    components(schemas(
        Message,
        Chat,
        MessageSubmitStreamingResponseMessage,
        UserProfile,
        MessageSubmitRequest
    ))
)]
pub struct ApiV1ApiDoc;

#[derive(Serialize, ToSchema)]
struct NotFound {
    error: String,
}

pub async fn fallback() -> impl IntoResponse {
    (
        StatusCode::NOT_FOUND,
        Json(NotFound {
            error:
                "There is no API route under the path (or path + method combination) you provided."
                    .to_string(),
        }),
    )
}

#[utoipa::path(
    get,
    path = "/me/profile",
    responses(
        (status = OK, body = UserProfile),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn profile(
    State(_app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
) -> Result<Json<UserProfile>, StatusCode> {
    Ok(Json(me_user.0))
}

#[derive(Serialize, ToSchema)]
pub struct Message {
    id: String,
}

#[derive(Serialize, ToSchema)]
pub struct Chat {
    id: String,
}

#[utoipa::path(get, path = "/messages", responses((status = OK, body = Vec<Message>)))]
pub async fn messages() -> Json<Vec<Message>> {
    vec![].into()
}

#[utoipa::path(get, path = "/chats", responses((status = OK, body = Vec<Chat>)))]
pub async fn chats() -> Json<Vec<Chat>> {
    vec![].into()
}

#[derive(Serialize, ToSchema)]
#[serde(tag = "message_type")]
enum MessageSubmitStreamingResponseMessage {
    #[serde(rename = "chat_created")]
    /// May optionally be sent at the start of the stream to indicate that a new chat has been created.
    ChatCreated(MessageSubmitStreamingResponseChatCreated),
    #[serde(rename = "user_message_saved")]
    /// Sent at the start of the stream to indicate that the user's message has been saved.
    UserMessageSaved(MessageSubmitStreamingResponseUserMessageSaved),
    #[serde(rename = "message_complete")]
    /// Sent when the assistant's response has been saved in full.
    MessageComplete(MessageSubmitStreamingResponseMessageComplete),
    #[serde(rename = "text_delta")]
    /// Sent whenever a new text chunk is generated by the assistant.
    TextDelta(MessageSubmitStreamingResponseMessageTextDelta),
    #[serde(rename = "example_other")]
    #[allow(unused)]
    ExampleOther(MessageSubmitStreamingResponseMessageOther),
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseChatCreated {
    chat_id: Uuid,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseUserMessageSaved {
    message_id: Uuid,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseMessageComplete {
    message_id: Uuid,
    full_text: String,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseMessageTextDelta {
    new_text: String,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
// TODO: This is just an example so that we have multiple variants to test against
struct MessageSubmitStreamingResponseMessageOther {
    foo: String,
}

#[derive(serde::Deserialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitRequest {
    #[schema(example = "00000000-0000-0000-0000-000000000000")]
    /// The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
    previous_message_id: Option<Uuid>,
    #[schema(example = "Hello, world!")]
    /// The text of the message.
    #[allow(dead_code)]
    user_message: String,
}

#[utoipa::path(
    post,
    path = "/me/messages/submitstream", 
    request_body = MessageSubmitRequest,
    responses(
        (status = OK, content_type="text/event-stream", body = MessageSubmitStreamingResponseMessage),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn message_submit_sse(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    Json(request): Json<MessageSubmitRequest>,
) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
    // Create a channel for sending events
    let (tx, rx) = tokio::sync::mpsc::channel::<Event>(100);

    // Spawn a task to process the request and send events
    tokio::spawn(async move {
        // Get or create the chat
        let result = get_or_create_chat(
            &app_state.db,
            app_state.policy(),
            &me_user.to_subject(),
            request.previous_message_id.as_ref(),
            &me_user.0.id,
        )
        .await;

        if let Ok((chat, chat_status)) = result {
            // Send chat created event if the chat was newly created
            if chat_status == ChatCreationStatus::Created {
                let chat_created = MessageSubmitStreamingResponseMessage::ChatCreated(
                    MessageSubmitStreamingResponseChatCreated { chat_id: chat.id },
                );
                if let Ok(json) = serde_json::to_string(&chat_created) {
                    let _ = tx
                        .send(Event::default().event("chat_created").data(json))
                        .await;
                }
            }

            // Create and save the user's message
            let user_message = json!({
                "role": "user",
                "content": request.user_message.clone(),
                "name": me_user.0.id
            });

            if let Ok(saved_user_message) = submit_message(
                &app_state.db,
                app_state.policy(),
                &me_user.to_subject(),
                &chat.id,
                user_message,
                request.previous_message_id.as_ref(),
            )
            .await
            {
                // Send user message saved event
                let user_message_saved = MessageSubmitStreamingResponseMessage::UserMessageSaved(
                    MessageSubmitStreamingResponseUserMessageSaved {
                        message_id: saved_user_message.id,
                    },
                );
                if let Ok(json) = serde_json::to_string(&user_message_saved) {
                    let _ = tx
                        .send(Event::default().event("user_message_saved").data(json))
                        .await;
                }

                let mut chat_request: ChatRequest = Default::default();
                // TODO: Initial system message?
                // TODO: Full previous message history
                chat_request = chat_request.append_message(ChatMessage::user(request.user_message));
                let chat_options = ChatOptions::default().with_capture_content(true);

                let chat_stream = app_state
                    .genai()
                    .exec_chat_stream("foo_model", chat_request, Some(&chat_options))
                    .await
                    .unwrap();
                let mut inner_stream = chat_stream.stream;
                // Await until stream end
                while let Some(Ok(message)) = inner_stream.next().await {
                    match message {
                        ChatStreamEvent::Chunk(chunk) => {
                            let delta = MessageSubmitStreamingResponseMessageTextDelta {
                                new_text: chunk.content,
                            };
                            let message = MessageSubmitStreamingResponseMessage::TextDelta(delta);
                            if let Ok(json) = serde_json::to_string(&message) {
                                let _ = tx
                                    .send(Event::default().event("text_delta").data(json))
                                    .await;
                            }
                        }
                        ChatStreamEvent::End(end) => {
                            let final_content = end
                                .captured_content
                                .unwrap()
                                .text_into_string()
                                .expect("Expected text response");

                            let assistant_message = json!({
                                "role": "assistant",
                                "content": final_content.clone(),
                            });
                            let saved_assistant_message = submit_message(
                                &app_state.db,
                                app_state.policy(),
                                &me_user.to_subject(),
                                &chat.id,
                                assistant_message.clone(),
                                Some(&saved_user_message.id),
                            )
                            .await
                            .unwrap();
                            let message_complete =
                                MessageSubmitStreamingResponseMessage::MessageComplete(
                                    MessageSubmitStreamingResponseMessageComplete {
                                        message_id: saved_assistant_message.id,
                                        full_text: final_content.clone(),
                                    },
                                );
                            if let Ok(json) = serde_json::to_string(&message_complete) {
                                let _ = tx
                                    .send(Event::default().event("message_complete").data(json))
                                    .await;
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
    });

    // Convert the receiver into a stream and return it
    let stream = tokio_stream::wrappers::ReceiverStream::new(rx).map(Ok);

    Sse::new(stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(1))
            .text("keep-alive-text"),
    )
}

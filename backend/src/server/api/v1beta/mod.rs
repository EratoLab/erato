#![allow(deprecated)]
pub mod me_profile_middleware;
pub mod message_streaming;

use crate::db::entity_ext::messages;
use crate::models;
use crate::models::chat::get_recent_chats;
use crate::models::message::MessageSchema;
use crate::server::api::v1beta::me_profile_middleware::{MeProfile, UserProfile};
use crate::server::api::v1beta::message_streaming::__path_message_submit_sse;
use crate::server::api::v1beta::message_streaming::message_submit_sse;
use crate::server::api::v1beta::message_streaming::{
    MessageSubmitRequest, MessageSubmitStreamingResponseMessage,
};
use crate::state::AppState;
use axum::extract::{Path, State};
use axum::http::StatusCode;
use axum::response::IntoResponse;
use axum::routing::{get, post};
use axum::{middleware, Extension, Json, Router};
use chrono::{DateTime, FixedOffset};
use eyre::Report;
use serde::Serialize;
use sqlx::types::{chrono, Uuid};
use utoipa::{OpenApi, ToSchema};
use utoipa_axum::router::OpenApiRouter;

pub fn router(app_state: AppState) -> OpenApiRouter<AppState> {
    // build our application with a route
    let me_routes = Router::new()
        .route("/profile", get(profile))
        .route("/messages/submitstream", post(message_submit_sse))
        .route("/recent_chats", get(recent_chats))
        .route_layer(middleware::from_fn_with_state(
            app_state.clone(),
            me_profile_middleware::user_profile_middleware,
        ));

    // authenticated routes that are not nested under /me
    // Should at a later time use a more generic middleware that can use a non-me profile as a Subject
    let authenticated_routes = Router::new()
        .route("/chats/:chat_id/messages", get(chat_messages))
        .route_layer(middleware::from_fn_with_state(
            app_state,
            me_profile_middleware::user_profile_middleware,
        ));

    let app = Router::new()
        .route("/messages", get(messages))
        .route("/chats", get(chats))
        .nest("/me", me_routes)
        .merge(authenticated_routes)
        .fallback(fallback);
    app.into()
}

#[derive(OpenApi)]
#[openapi(
    paths(
        messages,
        chats,
        recent_chats,
        message_submit_sse,
        profile,
        chat_messages
    ),
    components(schemas(
        Message,
        Chat,
        ChatMessage,
        RecentChat,
        MessageSubmitStreamingResponseMessage,
        UserProfile,
        MessageSubmitRequest
    ))
)]
pub struct ApiV1ApiDoc;

#[derive(Serialize, ToSchema)]
struct NotFound {
    error: String,
}

pub async fn fallback() -> impl IntoResponse {
    (
        StatusCode::NOT_FOUND,
        Json(NotFound {
            error:
                "There is no API route under the path (or path + method combination) you provided."
                    .to_string(),
        }),
    )
}

#[utoipa::path(
    get,
    path = "/me/profile",
    responses(
        (status = OK, body = UserProfile),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn profile(
    State(_app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
) -> Result<Json<UserProfile>, StatusCode> {
    Ok(Json(me_user.0))
}

#[derive(Serialize, ToSchema)]
pub struct Message {
    id: String,
}

#[deprecated = "Use RecentChat with /me/recent_chats instead"]
#[derive(Serialize, ToSchema)]
pub struct Chat {
    id: String,
}

#[derive(Serialize, ToSchema)]
pub struct RecentChat {
    id: String,
    /// Title of the chat, as generated by a summary of the chat.
    title_by_summary: String,
    /// Time of the last message in the chat.
    last_message_at: DateTime<FixedOffset>,
}

/// A message in a chat
#[derive(Serialize, ToSchema)]
pub struct ChatMessage {
    /// The unique ID of the message
    id: String,
    /// The ID of the chat this message belongs to
    chat_id: String,
    /// Role of the message sender. May be on of "user", "assistant", "system"
    role: String,
    /// The text content of the message
    full_text: String,
    /// When the message was created
    created_at: DateTime<FixedOffset>,
    /// When the message was last updated
    updated_at: DateTime<FixedOffset>,
    /// The ID of the previous message in the thread, if any
    previous_message_id: Option<String>,
    /// The ID of the sibling message, if any
    sibling_message_id: Option<String>,
    /// Whether this message is in the active thread
    is_message_in_active_thread: bool,
}

impl ChatMessage {
    pub fn from_model(msg: messages::Model) -> Result<Self, Report> {
        let parsed_message = MessageSchema::validate(&msg.raw_message)?;
        Ok(ChatMessage {
            id: msg.id.to_string(),
            chat_id: msg.chat_id.to_string(),
            role: parsed_message.role.to_string(),
            full_text: parsed_message.full_text(),
            created_at: msg.created_at,
            updated_at: msg.updated_at,
            previous_message_id: msg.previous_message_id.map(|id| id.to_string()),
            sibling_message_id: msg.sibling_message_id.map(|id| id.to_string()),
            is_message_in_active_thread: msg.is_message_in_active_thread,
        })
    }
}
#[utoipa::path(get, path = "/messages", responses((status = OK, body = Vec<Message>)))]
pub async fn messages() -> Json<Vec<Message>> {
    vec![].into()
}

#[deprecated = "Use /me/recent_chats instead"]
#[utoipa::path(get, path = "/chats", responses((status = OK, body = Vec<Chat>)))]
pub async fn chats() -> Json<Vec<Chat>> {
    Json(vec![Chat {
        id: "00000000-0000-0000-0000-000000000000".to_string(),
    }])
}

/// Get all messages for a specific chat
#[utoipa::path(
    get,
    path = "/chats/{chat_id}/messages",
    responses(
        (status = OK, body = Vec<ChatMessage>),
        (status = UNAUTHORIZED, description = "Unauthorized"),
        (status = FORBIDDEN, description = "Forbidden"),
        (status = NOT_FOUND, description = "Chat not found")
    ),
    params(
        ("chat_id" = String, Path, description = "The ID of the chat to get messages for")
    )
)]
pub async fn chat_messages(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    Path(chat_id): Path<String>,
) -> Result<Json<Vec<ChatMessage>>, StatusCode> {
    // Parse the chat ID
    let chat_id = Uuid::parse_str(&chat_id).map_err(|_| StatusCode::BAD_REQUEST)?;

    // Get the messages for this chat
    let messages = models::message::get_chat_messages(
        &app_state.db,
        app_state.policy(),
        &me_user.to_subject(),
        &chat_id,
    )
    .await
    .map_err(|e| {
        tracing::error!("Failed to get chat messages: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    // Convert the messages to the API response format
    let converted_messages: Result<_, Report> =
        messages.into_iter().map(ChatMessage::from_model).collect();

    let response = converted_messages.map_err(|e| {
        tracing::error!("Failed to get chat messages: {}", e);
        StatusCode::INTERNAL_SERVER_ERROR
    })?;

    Ok(Json(response))
}

#[utoipa::path(
    get,
    path = "/me/recent_chats", 
    params(
        ("limit" = Option<u64>, Query, description = "Maximum number of chats to return. Defaults to 30 if not provided."),
        ("offset" = Option<u64>, Query, description = "Number of chats to skip. Defaults to 0 if not provided.")
    ),
    responses(
        (status = OK, body = Vec<RecentChat>),
        (status = INTERNAL_SERVER_ERROR)
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn recent_chats(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String, String>>,
) -> Result<Json<Vec<RecentChat>>, StatusCode> {
    // Parse limit and offset from query parameters, with defaults
    let limit = params
        .get("limit")
        .and_then(|l| l.parse::<u64>().ok())
        .unwrap_or(30);
    let offset = params
        .get("offset")
        .and_then(|o| o.parse::<u64>().ok())
        .unwrap_or(0);

    // Get the user ID from the MeProfile
    let user_id = me_user.0.id.clone();

    // Call the get_recent_chats function
    let model_chats = get_recent_chats(
        &app_state.db,
        &app_state.policy,
        &me_user.to_subject(),
        &user_id,
        limit,
        offset,
    )
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // Convert from model RecentChat to API RecentChat
    let api_chats: Vec<RecentChat> = model_chats
        .into_iter()
        .map(|chat| RecentChat {
            id: chat.id,
            title_by_summary: chat.title_by_summary,
            last_message_at: chat.last_message_at,
        })
        .collect();

    Ok(Json(api_chats))
}

#![allow(deprecated)]
pub mod me_profile_middleware;

use crate::models::chat::{get_or_create_chat, get_recent_chats, ChatCreationStatus};
use crate::models::message::submit_message;
use crate::server::api::v1beta::me_profile_middleware::{MeProfile, UserProfile};
use crate::state::AppState;
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::sse::Event;
use axum::response::{IntoResponse, Sse};
use axum::routing::{get, post};
use axum::{middleware, Extension, Json, Router};
use chrono::{DateTime, FixedOffset};
use eyre::{eyre, Report};
use futures::stream::Stream;
use genai::chat::{ChatMessage, ChatOptions, ChatRequest, ChatStreamEvent};
use serde::Serialize;
use serde_json::{self, json};
use sqlx::types::{chrono, Uuid};
use std::time::Duration;
use tokio_stream::StreamExt as _;
use utoipa::{OpenApi, ToSchema};
use utoipa_axum::router::OpenApiRouter;

pub fn router(app_state: AppState) -> OpenApiRouter<AppState> {
    // build our application with a route
    let me_routes = Router::new()
        .route("/profile", get(profile))
        .route("/messages/submitstream", post(message_submit_sse))
        .route("/recent_chats", get(recent_chats))
        .route_layer(middleware::from_fn_with_state(
            app_state,
            me_profile_middleware::user_profile_middleware,
        ));

    let app = Router::new()
        .route("/messages", get(messages))
        .route("/chats", get(chats))
        .nest("/me", me_routes)
        .fallback(fallback);
    app.into()
}

#[derive(OpenApi)]
#[openapi(
    paths(messages, chats, recent_chats, message_submit_sse, profile),
    components(schemas(
        Message,
        Chat,
        RecentChat,
        MessageSubmitStreamingResponseMessage,
        UserProfile,
        MessageSubmitRequest
    ))
)]
pub struct ApiV1ApiDoc;

#[derive(Serialize, ToSchema)]
struct NotFound {
    error: String,
}

pub async fn fallback() -> impl IntoResponse {
    (
        StatusCode::NOT_FOUND,
        Json(NotFound {
            error:
                "There is no API route under the path (or path + method combination) you provided."
                    .to_string(),
        }),
    )
}

#[utoipa::path(
    get,
    path = "/me/profile",
    responses(
        (status = OK, body = UserProfile),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn profile(
    State(_app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
) -> Result<Json<UserProfile>, StatusCode> {
    Ok(Json(me_user.0))
}

#[derive(Serialize, ToSchema)]
pub struct Message {
    id: String,
}

#[deprecated = "Use RecentChat with /me/recent_chats instead"]
#[derive(Serialize, ToSchema)]
pub struct Chat {
    id: String,
}

#[derive(Serialize, ToSchema)]
pub struct RecentChat {
    id: String,
    /// Title of the chat, as generated by a summary of the chat.
    title_by_summary: String,
    /// Time of the last message in the chat.
    last_message_at: DateTime<FixedOffset>,
}

#[utoipa::path(get, path = "/messages", responses((status = OK, body = Vec<Message>)))]
pub async fn messages() -> Json<Vec<Message>> {
    vec![].into()
}

#[deprecated = "Use /me/recent_chats instead"]
#[utoipa::path(get, path = "/chats", responses((status = OK, body = Vec<Chat>)))]
pub async fn chats() -> Json<Vec<Chat>> {
    vec![].into()
}

#[utoipa::path(
    get,
    path = "/me/recent_chats", 
    params(
        ("limit" = Option<u64>, Query, description = "Maximum number of chats to return. Defaults to 30 if not provided."),
        ("offset" = Option<u64>, Query, description = "Number of chats to skip. Defaults to 0 if not provided.")
    ),
    responses(
        (status = OK, body = Vec<RecentChat>),
        (status = INTERNAL_SERVER_ERROR)
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn recent_chats(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String, String>>,
) -> Result<Json<Vec<RecentChat>>, StatusCode> {
    // Parse limit and offset from query parameters, with defaults
    let limit = params
        .get("limit")
        .and_then(|l| l.parse::<u64>().ok())
        .unwrap_or(30);
    let offset = params
        .get("offset")
        .and_then(|o| o.parse::<u64>().ok())
        .unwrap_or(0);

    // Get the user ID from the MeProfile
    let user_id = me_user.0.id.clone();

    // Call the get_recent_chats function
    let model_chats = get_recent_chats(
        &app_state.db,
        &app_state.policy,
        &me_user.to_subject(),
        &user_id,
        limit,
        offset,
    )
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // Convert from model RecentChat to API RecentChat
    let api_chats: Vec<RecentChat> = model_chats
        .into_iter()
        .map(|chat| RecentChat {
            id: chat.id,
            title_by_summary: chat.title_by_summary,
            last_message_at: chat.last_message_at,
        })
        .collect();

    Ok(Json(api_chats))
}

#[derive(Serialize, ToSchema)]
#[serde(tag = "message_type")]
enum MessageSubmitStreamingResponseMessage {
    #[serde(rename = "chat_created")]
    /// May optionally be sent at the start of the stream to indicate that a new chat has been created.
    ChatCreated(MessageSubmitStreamingResponseChatCreated),
    #[serde(rename = "user_message_saved")]
    /// Sent at the start of the stream to indicate that the user's message has been saved.
    UserMessageSaved(MessageSubmitStreamingResponseUserMessageSaved),
    #[serde(rename = "message_complete")]
    /// Sent when the assistant's response has been saved in full.
    MessageComplete(MessageSubmitStreamingResponseMessageComplete),
    #[serde(rename = "text_delta")]
    /// Sent whenever a new text chunk is generated by the assistant.
    TextDelta(MessageSubmitStreamingResponseMessageTextDelta),
    #[serde(rename = "example_other")]
    #[allow(unused)]
    ExampleOther(MessageSubmitStreamingResponseMessageOther),
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseChatCreated {
    chat_id: Uuid,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseUserMessageSaved {
    message_id: Uuid,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseMessageComplete {
    message_id: Uuid,
    full_text: String,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
struct MessageSubmitStreamingResponseMessageTextDelta {
    new_text: String,
}

#[derive(Serialize, ToSchema)]
#[serde(rename_all = "snake_case")]
// TODO: This is just an example so that we have multiple variants to test against
struct MessageSubmitStreamingResponseMessageOther {
    foo: String,
}

#[derive(serde::Deserialize, ToSchema)]
#[serde(rename_all = "snake_case")]
pub struct MessageSubmitRequest {
    #[schema(example = "00000000-0000-0000-0000-000000000000")]
    /// The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
    previous_message_id: Option<Uuid>,
    #[schema(example = "Hello, world!")]
    /// The text of the message.
    #[allow(dead_code)]
    user_message: String,
}

#[utoipa::path(
    post,
    path = "/me/messages/submitstream", 
    request_body = MessageSubmitRequest,
    responses(
        (status = OK, content_type="text/event-stream", body = MessageSubmitStreamingResponseMessage),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided"),
        (status = INTERNAL_SERVER_ERROR, description = "When an internal server error occurs")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn message_submit_sse(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    Json(request): Json<MessageSubmitRequest>,
) -> Sse<impl Stream<Item = Result<Event, Report>>> {
    // Create a channel for sending events
    let (tx, rx) = tokio::sync::mpsc::channel::<Result<Event, Report>>(100);

    // Spawn a task to process the request and send events
    tokio::spawn(async move {
        // Get or create the chat
        let result = get_or_create_chat(
            &app_state.db,
            app_state.policy(),
            &me_user.to_subject(),
            request.previous_message_id.as_ref(),
            &me_user.0.id,
        )
        .await;

        match result {
            Ok((chat, chat_status)) => {
                // Send chat created event if the chat was newly created
                if chat_status == ChatCreationStatus::Created {
                    let chat_created = MessageSubmitStreamingResponseMessage::ChatCreated(
                        MessageSubmitStreamingResponseChatCreated { chat_id: chat.id },
                    );
                    match serde_json::to_string(&chat_created) {
                        Ok(json) => {
                            if let Err(err) = tx
                                .send(Ok(Event::default().event("chat_created").data(json)))
                                .await
                            {
                                let _ = tx
                                    .send(Err(eyre!("Failed to send chat_created event: {}", err)))
                                    .await;
                                return;
                            }
                        }
                        Err(err) => {
                            let _ = tx
                                .send(Err(eyre!(
                                    "Failed to serialize chat_created event: {}",
                                    err
                                )))
                                .await;
                            return;
                        }
                    }
                }

                // Create and save the user's message
                let user_message = json!({
                    "role": "user",
                    "content": request.user_message.clone(),
                    "name": me_user.0.id
                });

                let saved_user_message = match submit_message(
                    &app_state.db,
                    app_state.policy(),
                    &me_user.to_subject(),
                    &chat.id,
                    user_message,
                    request.previous_message_id.as_ref(),
                    // TODO: Add support for sibling message regenerate
                    None,
                    None,
                )
                .await
                {
                    Ok(msg) => msg,
                    Err(err) => {
                        let _ = tx
                            .send(Err(eyre!("Failed to submit user message: {}", err)))
                            .await;
                        return;
                    }
                };

                // Send user message saved event
                let user_message_saved = MessageSubmitStreamingResponseMessage::UserMessageSaved(
                    MessageSubmitStreamingResponseUserMessageSaved {
                        message_id: saved_user_message.id,
                    },
                );
                match serde_json::to_string(&user_message_saved) {
                    Ok(json) => {
                        if let Err(err) = tx
                            .send(Ok(Event::default().event("user_message_saved").data(json)))
                            .await
                        {
                            let _ = tx
                                .send(Err(eyre!(
                                    "Failed to send user_message_saved event: {}",
                                    err
                                )))
                                .await;
                            return;
                        }
                    }
                    Err(err) => {
                        let _ = tx
                            .send(Err(eyre!(
                                "Failed to serialize user_message_saved event: {}",
                                err
                            )))
                            .await;
                        return;
                    }
                }

                let mut chat_request: ChatRequest = Default::default();
                // TODO: Initial system message?
                // TODO: Full previous message history
                chat_request = chat_request.append_message(ChatMessage::user(request.user_message));
                let chat_options = ChatOptions::default().with_capture_content(true);

                let chat_stream = match app_state
                    .genai()
                    .exec_chat_stream("foo_model", chat_request, Some(&chat_options))
                    .await
                {
                    Ok(stream) => stream,
                    Err(err) => {
                        let _ = tx
                            .send(Err(eyre!("Failed to execute chat stream: {}", err)))
                            .await;
                        return;
                    }
                };

                let mut inner_stream = chat_stream.stream;
                // Await until stream end
                while let Some(result) = inner_stream.next().await {
                    match result {
                        Ok(message) => {
                            match message {
                                ChatStreamEvent::Chunk(chunk) => {
                                    let delta = MessageSubmitStreamingResponseMessageTextDelta {
                                        new_text: chunk.content,
                                    };
                                    let message =
                                        MessageSubmitStreamingResponseMessage::TextDelta(delta);
                                    match serde_json::to_string(&message) {
                                        Ok(json) => {
                                            if let Err(err) = tx
                                                .send(Ok(Event::default()
                                                    .event("text_delta")
                                                    .data(json)))
                                                .await
                                            {
                                                let _ = tx
                                                    .send(Err(eyre!(
                                                        "Failed to send text_delta event: {}",
                                                        err
                                                    )))
                                                    .await;
                                                return;
                                            }
                                        }
                                        Err(err) => {
                                            let _ = tx
                                                .send(Err(eyre!(
                                                    "Failed to serialize text_delta event: {}",
                                                    err
                                                )))
                                                .await;
                                            return;
                                        }
                                    }
                                }
                                ChatStreamEvent::End(end) => {
                                    let final_content = match end
                                        .captured_content
                                        .ok_or_else(|| {
                                            eyre!("No captured content in chat stream end event")
                                        })
                                        .map(|content| {
                                            content
                                                .text_into_string()
                                                .expect("Expected text response")
                                        }) {
                                        Ok(content) => content,
                                        Err(err) => {
                                            let _ = tx.send(Err(err)).await;
                                            return;
                                        }
                                    };

                                    let assistant_message = json!({
                                        "role": "assistant",
                                        "content": final_content.clone(),
                                    });

                                    let saved_assistant_message = match submit_message(
                                        &app_state.db,
                                        app_state.policy(),
                                        &me_user.to_subject(),
                                        &chat.id,
                                        assistant_message.clone(),
                                        Some(&saved_user_message.id),
                                        None,
                                        // TODO: Save input messages here
                                        None,
                                    )
                                    .await
                                    {
                                        Ok(msg) => msg,
                                        Err(err) => {
                                            let _ = tx
                                                .send(Err(eyre!(
                                                    "Failed to submit assistant message: {}",
                                                    err
                                                )))
                                                .await;
                                            return;
                                        }
                                    };

                                    let message_complete =
                                        MessageSubmitStreamingResponseMessage::MessageComplete(
                                            MessageSubmitStreamingResponseMessageComplete {
                                                message_id: saved_assistant_message.id,
                                                full_text: final_content.clone(),
                                            },
                                        );
                                    match serde_json::to_string(&message_complete) {
                                        Ok(json) => {
                                            if let Err(err) = tx
                                                .send(Ok(Event::default()
                                                    .event("message_complete")
                                                    .data(json)))
                                                .await
                                            {
                                                let _ = tx
                                                    .send(Err(eyre!(
                                                        "Failed to send message_complete event: {}",
                                                        err
                                                    )))
                                                    .await;
                                                return;
                                            }
                                        }
                                        Err(err) => {
                                            let _ = tx.send(Err(eyre!("Failed to serialize message_complete event: {}", err))).await;
                                            return;
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        Err(err) => {
                            let _ = tx.send(Err(eyre!("Error from chat stream: {}", err))).await;
                            return;
                        }
                    }
                }
            }
            Err(err) => {
                let _ = tx
                    .send(Err(eyre!("Failed to get or create chat: {}", err)))
                    .await;
            }
        }
    });

    // Convert the receiver into a stream and return it
    let stream = tokio_stream::wrappers::ReceiverStream::new(rx);

    Sse::new(stream).keep_alive(
        axum::response::sse::KeepAlive::new()
            .interval(Duration::from_secs(1))
            .text("keep-alive-text"),
    )
}

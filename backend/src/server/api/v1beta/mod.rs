#![allow(deprecated)]
pub mod me_profile_middleware;
pub mod message_streaming;

use crate::db::entity_ext::messages;
use crate::models;
use crate::models::chat::get_recent_chats;
use crate::models::message::MessageSchema;
use crate::server::api::v1beta::me_profile_middleware::{MeProfile, UserProfile};
use crate::server::api::v1beta::message_streaming::message_submit_sse;
use crate::server::api::v1beta::message_streaming::{
    MessageSubmitRequest, MessageSubmitStreamingResponseMessage,
};
use crate::server::api::v1beta::message_streaming::{
    __path_message_submit_sse, __path_regenerate_message_sse, regenerate_message_sse,
};
use crate::state::AppState;
use axum::extract::{Path, State};
use axum::http::StatusCode;
use axum::response::IntoResponse;
use axum::routing::{get, post};
use axum::{middleware, Extension, Json, Router};
use axum_extra::extract::Multipart;
use chrono::{DateTime, FixedOffset};
use eyre::{Report, WrapErr};
use sentry::{event_from_error, Hub};
use serde::{Deserialize, Serialize};
use sqlx::types::{chrono, Uuid};
use std::error::Error;
use utoipa::{OpenApi, ToSchema};
use utoipa_axum::router::OpenApiRouter;

pub fn router(app_state: AppState) -> OpenApiRouter<AppState> {
    // build our application with a route
    let me_routes = Router::new()
        .route("/profile", get(profile))
        .route("/messages/submitstream", post(message_submit_sse))
        .route("/messages/regeneratestream", post(regenerate_message_sse))
        .route("/recent_chats", get(recent_chats))
        .route("/files", post(upload_file))
        .route_layer(middleware::from_fn_with_state(
            app_state.clone(),
            me_profile_middleware::user_profile_middleware,
        ));

    // authenticated routes that are not nested under /me
    // Should at a later time use a more generic middleware that can use a non-me profile as a Subject
    let authenticated_routes = Router::new()
        .route("/chats/:chat_id/messages", get(chat_messages))
        .route_layer(middleware::from_fn_with_state(
            app_state,
            me_profile_middleware::user_profile_middleware,
        ));

    let app = Router::new()
        .route("/messages", get(messages))
        .route("/chats", get(chats))
        .nest("/me", me_routes)
        .merge(authenticated_routes)
        .fallback(fallback);
    app.into()
}

#[derive(OpenApi)]
#[openapi(
    paths(
        messages,
        chats,
        profile,
        chat_messages,
        recent_chats,
        upload_file,
        message_submit_sse,
        regenerate_message_sse
    ),
    components(schemas(
        Message,
        Chat,
        RecentChat,
        ChatMessage,
        ChatMessageStats,
        ChatMessagesResponse,
        RecentChatStats,
        RecentChatsResponse,
        FileUploadItem,
        FileUploadResponse,
        MessageSubmitStreamingResponseMessage,
        UserProfile,
        MessageSubmitRequest
    ))
)]
pub struct ApiV1ApiDoc;

#[derive(Serialize, ToSchema)]
struct NotFound {
    error: String,
}

pub async fn fallback() -> impl IntoResponse {
    (
        StatusCode::NOT_FOUND,
        Json(NotFound {
            error:
                "There is no API route under the path (or path + method combination) you provided."
                    .to_string(),
        }),
    )
}

#[utoipa::path(
    get,
    path = "/me/profile",
    responses(
        (status = OK, body = UserProfile),
        (status = UNAUTHORIZED, description = "When no valid JWT token is provided")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn profile(
    State(_app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
) -> Result<Json<UserProfile>, StatusCode> {
    Ok(Json(me_user.0))
}

#[derive(Serialize, ToSchema)]
pub struct Message {
    id: String,
}

#[deprecated = "Use RecentChat with /me/recent_chats instead"]
#[derive(Serialize, ToSchema)]
pub struct Chat {
    id: String,
}

#[derive(Debug, ToSchema, Serialize)]
pub struct RecentChat {
    id: String,
    /// Title of the chat, as generated by a summary of the chat.
    title_by_summary: String,
    /// Time of the last message in the chat.
    last_message_at: DateTime<FixedOffset>,
}

/// A message in a chat
#[derive(Debug, ToSchema, Serialize)]
pub struct ChatMessage {
    /// The unique ID of the message
    id: String,
    /// The ID of the chat this message belongs to
    chat_id: String,
    /// Role of the message sender. May be on of "user", "assistant", "system"
    role: String,
    /// The text content of the message
    full_text: String,
    /// When the message was created
    created_at: DateTime<FixedOffset>,
    /// When the message was last updated
    updated_at: DateTime<FixedOffset>,
    /// The ID of the previous message in the thread, if any
    previous_message_id: Option<String>,
    /// The unique ID of the sibling message, if any
    sibling_message_id: Option<String>,
    /// Whether this message is in the active thread
    is_message_in_active_thread: bool,
}

/// Statistics for a list of chat messages
#[derive(Debug, ToSchema, Serialize)]
pub struct ChatMessageStats {
    /// Total number of messages in the chat
    total_count: i64,
    /// Current offset in the list
    current_offset: u64,
    /// Number of messages in the current response
    returned_count: usize,
    /// Whether there are more messages available
    has_more: bool,
}

/// Response for the chat_messages endpoint
#[derive(Debug, ToSchema, Serialize)]
pub struct ChatMessagesResponse {
    /// The list of messages
    messages: Vec<ChatMessage>,
    /// Statistics about the message list
    stats: ChatMessageStats,
}

/// Statistics for a list of recent chats
#[derive(Debug, ToSchema, Serialize)]
pub struct RecentChatStats {
    /// Total number of chats available
    total_count: i64,
    /// Current offset in the list
    current_offset: u64,
    /// Number of chats in the current response
    returned_count: usize,
    /// Whether there are more chats available
    has_more: bool,
}

/// Response for the recent_chats endpoint
#[derive(Debug, ToSchema, Serialize)]
pub struct RecentChatsResponse {
    /// The list of recent chats
    chats: Vec<RecentChat>,
    /// Statistics about the chat list
    stats: RecentChatStats,
}

#[derive(Deserialize, ToSchema)]
#[allow(unused)]
struct MultipartFormFile {
    name: String,
    #[schema(format = Binary, content_media_type = "application/octet-stream")]
    file: String,
}

/// Response for file upload
#[derive(Serialize, ToSchema)]
pub struct FileUploadItem {
    /// The unique ID of the uploaded file
    id: String,
    /// The original filename of the uploaded file
    filename: String,
}

/// Response for file upload
#[derive(Serialize, ToSchema)]
pub struct FileUploadResponse {
    /// The list of uploaded files with their IDs and filenames
    files: Vec<FileUploadItem>,
}

/// Upload files and return UUIDs for each
///
/// This endpoint accepts a multipart form with one or more files and returns UUIDs for each.
#[utoipa::path(
    post,
    path = "/me/files",
    tag = "files",
    request_body(content = Vec<MultipartFormFile>, description = "Files to upload", content_type = "multipart/form-data"),
    responses(
        (status = OK, body = FileUploadResponse),
        (status = BAD_REQUEST, description = "Invalid file upload"),
        (status = INTERNAL_SERVER_ERROR, description = "Server error"),
    )
)]
pub async fn upload_file(
    State(_app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    mut multipart: Multipart,
) -> Result<Json<FileUploadResponse>, StatusCode> {
    let mut uploaded_files = Vec::new();

    // Process the multipart form
    while let Some(field) = multipart.next_field().await.map_err(|e| {
        tracing::error!("Failed to process multipart form: {}", e);
        StatusCode::BAD_REQUEST
    })? {
        // Read the field's contents
        let filename = field
            .file_name()
            .map(|s| s.to_string())
            .unwrap_or_else(|| "unnamed_file".to_string());
        let _content_type = field.content_type().map(|s| s.to_string());

        let data = field.bytes().await.map_err(|e| {
            tracing::error!("Failed to read file data: {}", e);
            StatusCode::INTERNAL_SERVER_ERROR
        })?;

        // Generate a random UUID
        let file_id = Uuid::new_v4().to_string();

        // In a real implementation, you would store the file data somewhere
        // For now, we just log the size and return the UUID
        tracing::info!(
            "User {} uploaded file '{}' with size {} bytes, assigned ID: {}",
            me_user.0.id,
            filename,
            data.len(),
            file_id
        );

        // Add this file to our list of uploaded files
        uploaded_files.push(FileUploadItem {
            id: file_id,
            filename,
        });
    }

    // If no files were uploaded, return an error
    if uploaded_files.is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Return the list of uploaded files
    Ok(Json(FileUploadResponse {
        files: uploaded_files,
    }))
}

impl ChatMessage {
    pub fn from_model(msg: messages::Model) -> Result<Self, Report> {
        let parsed_message = MessageSchema::validate(&msg.raw_message)?;
        Ok(ChatMessage {
            id: msg.id.to_string(),
            chat_id: msg.chat_id.to_string(),
            role: parsed_message.role.to_string(),
            full_text: parsed_message.full_text(),
            created_at: msg.created_at,
            updated_at: msg.updated_at,
            previous_message_id: msg.previous_message_id.map(|id| id.to_string()),
            sibling_message_id: msg.sibling_message_id.map(|id| id.to_string()),
            is_message_in_active_thread: msg.is_message_in_active_thread,
        })
    }
}
#[utoipa::path(get, path = "/messages", responses((status = OK, body = Vec<Message>)))]
pub async fn messages() -> Json<Vec<Message>> {
    vec![].into()
}

#[deprecated = "Use /me/recent_chats instead"]
#[utoipa::path(get, path = "/chats", responses((status = OK, body = Vec<Chat>)))]
pub async fn chats() -> Json<Vec<Chat>> {
    Json(vec![Chat {
        id: "00000000-0000-0000-0000-000000000000".to_string(),
    }])
}

/// Get all messages for a specific chat
#[utoipa::path(
    get,
    path = "/chats/{chat_id}/messages", 
    params(
        ("chat_id" = String, Path, description = "The ID of the chat to get messages for"),
        ("limit" = Option<u64>, Query, description = "Maximum number of messages to return per page. Defaults to 100 if not provided. Larger values may impact performance."),
        ("offset" = Option<u64>, Query, description = "Number of messages to skip for pagination. Defaults to 0 if not provided.")
    ),
    responses(
        (status = OK, body = ChatMessagesResponse, description = "Successfully retrieved messages with pagination metadata"),
        (status = BAD_REQUEST, description = "Invalid chat ID format"),
        (status = INTERNAL_SERVER_ERROR, description = "Server error while retrieving messages")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn chat_messages(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    Path(chat_id): Path<String>,
    axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String, String>>,
) -> Result<Json<ChatMessagesResponse>, StatusCode> {
    // Parse the chat ID
    let chat_id = Uuid::parse_str(&chat_id).map_err(|_| StatusCode::BAD_REQUEST)?;

    // Parse pagination parameters
    let limit = params.get("limit").and_then(|l| l.parse::<u64>().ok());

    let offset = params.get("offset").and_then(|o| o.parse::<u64>().ok());

    // Get the messages for this chat
    let (messages, stats) = models::message::get_chat_messages(
        &app_state.db,
        app_state.policy(),
        &me_user.to_subject(),
        &chat_id,
        limit,
        offset,
    )
    .await
    .wrap_err("Failed to get chat messages")
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // Convert the messages to the API response format
    let converted_messages: Result<_, Report> =
        messages.into_iter().map(ChatMessage::from_model).collect();

    let response_messages = converted_messages
        .wrap_err("Failed to get chat messages")
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    // Create the response with messages and stats
    let response = ChatMessagesResponse {
        messages: response_messages,
        stats: ChatMessageStats {
            total_count: stats.total_count,
            current_offset: stats.current_offset,
            returned_count: stats.returned_count,
            has_more: stats.has_more,
        },
    };

    Ok(Json(response))
}

#[utoipa::path(
    get,
    path = "/me/recent_chats", 
    params(
        ("limit" = Option<u64>, Query, description = "Maximum number of chats to return per page. Defaults to 30 if not provided. Larger values may impact performance."),
        ("offset" = Option<u64>, Query, description = "Number of chats to skip for pagination. Defaults to 0 if not provided.")
    ),
    responses(
        (status = OK, body = RecentChatsResponse, description = "Successfully retrieved chats with pagination metadata"),
        (status = INTERNAL_SERVER_ERROR, description = "Server error while retrieving chats")
    ),
    security(
        ("bearer_auth" = [])
    )
)]
pub async fn recent_chats(
    State(app_state): State<AppState>,
    Extension(me_user): Extension<MeProfile>,
    axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String, String>>,
) -> Result<Json<RecentChatsResponse>, StatusCode> {
    // Parse limit and offset from query parameters, with defaults
    let limit = params
        .get("limit")
        .and_then(|l| l.parse::<u64>().ok())
        .unwrap_or(30);
    let offset = params
        .get("offset")
        .and_then(|o| o.parse::<u64>().ok())
        .unwrap_or(0);

    // Get the user ID from the MeProfile
    let user_id = me_user.0.id.clone();

    // Call the get_recent_chats function
    let (model_chats, stats) = get_recent_chats(
        &app_state.db,
        &app_state.policy,
        &me_user.to_subject(),
        &user_id,
        limit,
        offset,
    )
    .await
    .map_err(log_internal_server_error)?;

    // Convert from model RecentChat to API RecentChat
    let api_chats: Vec<RecentChat> = model_chats
        .into_iter()
        .map(|chat| RecentChat {
            id: chat.id,
            title_by_summary: chat.title_by_summary,
            last_message_at: chat.last_message_at,
        })
        .collect();

    // Create the response with chats and stats
    let response = RecentChatsResponse {
        chats: api_chats,
        stats: RecentChatStats {
            total_count: stats.total_count,
            current_offset: stats.current_offset,
            returned_count: stats.returned_count,
            has_more: stats.has_more,
        },
    };

    Ok(Json(response))
}

#[cfg(feature = "sentry")]
fn log_internal_server_error(report: Report) -> StatusCode {
    Hub::with_active(|hub| {
        let err: &dyn Error = report.as_ref();
        let event = event_from_error(err);
        // if let Some(exc) = event.exception.iter_mut().last() {
        //     let backtrace = err.backtrace();
        //     exc.stacktrace = sentry_backtrace::parse_stacktrace(&format!("{backtrace:#}"));
        // }

        hub.capture_event(event);
    });
    StatusCode::INTERNAL_SERVER_ERROR
}

#[cfg(not(feature = "sentry"))]
fn log_internal_server_error(err: Report) -> StatusCode {
    tracing::error!("{}", err.to_string());
    StatusCode::INTERNAL_SERVER_ERROR
}

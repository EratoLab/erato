/**
 * Generated by @openapi-codegen
 *
 * @version
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useV1betaApiContext,
  V1betaApiContext,
  queryKeyFn,
} from "./v1betaApiContext";
import { deepMerge } from "./v1betaApiUtils";
import type * as Fetcher from "./v1betaApiFetcher";
import { v1betaApiFetch } from "./v1betaApiFetcher";
import type * as Schemas from "./v1betaApiSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type ChatsError = Fetcher.ErrorWrapper<undefined>;

export type ChatsResponse = Schemas.Chat[];

export type ChatsVariables = V1betaApiContext["fetcherOptions"];

export const fetchChats = (variables: ChatsVariables, signal?: AbortSignal) =>
  v1betaApiFetch<ChatsResponse, ChatsError, undefined, {}, {}, {}>({
    url: "/api/v1beta/chats",
    method: "get",
    ...variables,
    signal,
  });

export function chatsQuery(variables: ChatsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ChatsResponse>;
};

export function chatsQuery(variables: ChatsVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<ChatsResponse>)
    | reactQuery.SkipToken;
};

export function chatsQuery(variables: ChatsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/chats",
      operationId: "chats",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchChats(variables, signal),
  };
}

export const useSuspenseChats = <TData = ChatsResponse,>(
  variables: ChatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatsResponse, ChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<ChatsResponse, ChatsError, TData>({
    ...chatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useChats = <TData = ChatsResponse,>(
  variables: ChatsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatsResponse, ChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<ChatsResponse, ChatsError, TData>({
    ...chatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type ChatMessagesPathParams = {
  /**
   * The ID of the chat to get messages for
   */
  chatId: string;
};

export type ChatMessagesError = Fetcher.ErrorWrapper<undefined>;

export type ChatMessagesResponse = Schemas.ChatMessage[];

export type ChatMessagesVariables = {
  pathParams: ChatMessagesPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchChatMessages = (
  variables: ChatMessagesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    ChatMessagesResponse,
    ChatMessagesError,
    undefined,
    {},
    {},
    ChatMessagesPathParams
  >({
    url: "/api/v1beta/chats/{chatId}/messages",
    method: "get",
    ...variables,
    signal,
  });

export function chatMessagesQuery(variables: ChatMessagesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ChatMessagesResponse>;
};

export function chatMessagesQuery(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<ChatMessagesResponse>)
    | reactQuery.SkipToken;
};

export function chatMessagesQuery(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/chats/{chatId}/messages",
      operationId: "chatMessages",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchChatMessages(variables, signal),
  };
}

export const useSuspenseChatMessages = <TData = ChatMessagesResponse,>(
  variables: ChatMessagesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatMessagesResponse, ChatMessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    ChatMessagesResponse,
    ChatMessagesError,
    TData
  >({
    ...chatMessagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useChatMessages = <TData = ChatMessagesResponse,>(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatMessagesResponse, ChatMessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<ChatMessagesResponse, ChatMessagesError, TData>({
    ...chatMessagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type MessageSubmitSseError = Fetcher.ErrorWrapper<undefined>;

export type MessageSubmitSseVariables = {
  body: Schemas.MessageSubmitRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchMessageSubmitSse = (
  variables: MessageSubmitSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    MessageSubmitSseError,
    Schemas.MessageSubmitRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/submitstream",
    method: "post",
    ...variables,
    signal,
  });

export const useMessageSubmitSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      MessageSubmitSseError,
      MessageSubmitSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    MessageSubmitSseError,
    MessageSubmitSseVariables
  >({
    mutationFn: (variables: MessageSubmitSseVariables) =>
      fetchMessageSubmitSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ProfileError = Fetcher.ErrorWrapper<undefined>;

export type ProfileVariables = V1betaApiContext["fetcherOptions"];

export const fetchProfile = (
  variables: ProfileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<Schemas.UserProfile, ProfileError, undefined, {}, {}, {}>({
    url: "/api/v1beta/me/profile",
    method: "get",
    ...variables,
    signal,
  });

export function profileQuery(variables: ProfileVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserProfile>;
};

export function profileQuery(
  variables: ProfileVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UserProfile>)
    | reactQuery.SkipToken;
};

export function profileQuery(
  variables: ProfileVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/profile",
      operationId: "profile",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchProfile(variables, signal),
  };
}

export const useSuspenseProfile = <TData = Schemas.UserProfile,>(
  variables: ProfileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, ProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<Schemas.UserProfile, ProfileError, TData>({
    ...profileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useProfile = <TData = Schemas.UserProfile,>(
  variables: ProfileVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, ProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<Schemas.UserProfile, ProfileError, TData>({
    ...profileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type RecentChatsQueryParams = {
  /**
   * Maximum number of chats to return. Defaults to 30 if not provided.
   *
   * @format int64
   * @minimum 0
   */
  limit?: number;
  /**
   * Number of chats to skip. Defaults to 0 if not provided.
   *
   * @format int64
   * @minimum 0
   */
  offset?: number;
};

export type RecentChatsError = Fetcher.ErrorWrapper<undefined>;

export type RecentChatsResponse = Schemas.RecentChat[];

export type RecentChatsVariables = {
  queryParams?: RecentChatsQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchRecentChats = (
  variables: RecentChatsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    RecentChatsResponse,
    RecentChatsError,
    undefined,
    {},
    RecentChatsQueryParams,
    {}
  >({
    url: "/api/v1beta/me/recent_chats",
    method: "get",
    ...variables,
    signal,
  });

export function recentChatsQuery(variables: RecentChatsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<RecentChatsResponse>;
};

export function recentChatsQuery(
  variables: RecentChatsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<RecentChatsResponse>)
    | reactQuery.SkipToken;
};

export function recentChatsQuery(
  variables: RecentChatsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/recent_chats",
      operationId: "recentChats",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchRecentChats(variables, signal),
  };
}

export const useSuspenseRecentChats = <TData = RecentChatsResponse,>(
  variables: RecentChatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<RecentChatsResponse, RecentChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    RecentChatsResponse,
    RecentChatsError,
    TData
  >({
    ...recentChatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecentChats = <TData = RecentChatsResponse,>(
  variables: RecentChatsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<RecentChatsResponse, RecentChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<RecentChatsResponse, RecentChatsError, TData>({
    ...recentChatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type MessagesError = Fetcher.ErrorWrapper<undefined>;

export type MessagesResponse = Schemas.Message[];

export type MessagesVariables = V1betaApiContext["fetcherOptions"];

export const fetchMessages = (
  variables: MessagesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<MessagesResponse, MessagesError, undefined, {}, {}, {}>({
    url: "/api/v1beta/messages",
    method: "get",
    ...variables,
    signal,
  });

export function messagesQuery(variables: MessagesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MessagesResponse>;
};

export function messagesQuery(
  variables: MessagesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MessagesResponse>)
    | reactQuery.SkipToken;
};

export function messagesQuery(
  variables: MessagesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/messages",
      operationId: "messages",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchMessages(variables, signal),
  };
}

export const useSuspenseMessages = <TData = MessagesResponse,>(
  variables: MessagesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<MessagesResponse, MessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<MessagesResponse, MessagesError, TData>({
    ...messagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMessages = <TData = MessagesResponse,>(
  variables: MessagesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<MessagesResponse, MessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<MessagesResponse, MessagesError, TData>({
    ...messagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type HealthError = Fetcher.ErrorWrapper<undefined>;

export type HealthVariables = V1betaApiContext["fetcherOptions"];

export const fetchHealth = (variables: HealthVariables, signal?: AbortSignal) =>
  v1betaApiFetch<undefined, HealthError, undefined, {}, {}, {}>({
    url: "/health",
    method: "get",
    ...variables,
    signal,
  });

export function healthQuery(variables: HealthVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function healthQuery(
  variables: HealthVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function healthQuery(variables: HealthVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/health",
      operationId: "health",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchHealth(variables, signal),
  };
}

export const useSuspenseHealth = <TData = undefined,>(
  variables: HealthVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, HealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<undefined, HealthError, TData>({
    ...healthQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useHealth = <TData = undefined,>(
  variables: HealthVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, HealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<undefined, HealthError, TData>({
    ...healthQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/v1beta/chats";
      operationId: "chats";
      variables: ChatsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/chats/{chatId}/messages";
      operationId: "chatMessages";
      variables: ChatMessagesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/profile";
      operationId: "profile";
      variables: ProfileVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/recent_chats";
      operationId: "recentChats";
      variables: RecentChatsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/messages";
      operationId: "messages";
      variables: MessagesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/health";
      operationId: "health";
      variables: HealthVariables | reactQuery.SkipToken;
    };

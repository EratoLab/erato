/**
 * Generated by @openapi-codegen
 *
 * @version
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useV1betaApiContext,
  V1betaApiContext,
  queryKeyFn,
} from "./v1betaApiContext";
import { deepMerge } from "./v1betaApiUtils";
import type * as Fetcher from "./v1betaApiFetcher";
import { v1betaApiFetch } from "./v1betaApiFetcher";
import type * as Schemas from "./v1betaApiSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type ChatsError = Fetcher.ErrorWrapper<undefined>;

export type ChatsResponse = Schemas.Chat[];

export type ChatsVariables = V1betaApiContext["fetcherOptions"];

export const fetchChats = (variables: ChatsVariables, signal?: AbortSignal) =>
  v1betaApiFetch<ChatsResponse, ChatsError, undefined, {}, {}, {}>({
    url: "/api/v1beta/chats",
    method: "get",
    ...variables,
    signal,
  });

export function chatsQuery(variables: ChatsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ChatsResponse>;
};

export function chatsQuery(variables: ChatsVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<ChatsResponse>)
    | reactQuery.SkipToken;
};

export function chatsQuery(variables: ChatsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/chats",
      operationId: "chats",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchChats(variables, signal),
  };
}

export const useSuspenseChats = <TData = ChatsResponse,>(
  variables: ChatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatsResponse, ChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<ChatsResponse, ChatsError, TData>({
    ...chatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useChats = <TData = ChatsResponse,>(
  variables: ChatsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatsResponse, ChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<ChatsResponse, ChatsError, TData>({
    ...chatsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArchiveChatEndpointPathParams = {
  /**
   * The ID of the chat to archive
   */
  chatId: string;
};

export type ArchiveChatEndpointError = Fetcher.ErrorWrapper<undefined>;

export type ArchiveChatEndpointVariables = {
  body?: Schemas.ArchiveChatRequest;
  pathParams: ArchiveChatEndpointPathParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint marks a chat as archived by setting its archived_at timestamp.
 * Archived chats can be filtered out from the recent chats listing by default.
 */
export const fetchArchiveChatEndpoint = (
  variables: ArchiveChatEndpointVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.ArchiveChatResponse,
    ArchiveChatEndpointError,
    Schemas.ArchiveChatRequest,
    {},
    {},
    ArchiveChatEndpointPathParams
  >({
    url: "/api/v1beta/chats/{chatId}/archive",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint marks a chat as archived by setting its archived_at timestamp.
 * Archived chats can be filtered out from the recent chats listing by default.
 */
export const useArchiveChatEndpoint = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ArchiveChatResponse,
      ArchiveChatEndpointError,
      ArchiveChatEndpointVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.ArchiveChatResponse,
    ArchiveChatEndpointError,
    ArchiveChatEndpointVariables
  >({
    mutationFn: (variables: ArchiveChatEndpointVariables) =>
      fetchArchiveChatEndpoint(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ChatMessagesPathParams = {
  /**
   * The ID of the chat to get messages for
   */
  chatId: string;
};

export type ChatMessagesQueryParams = {
  /**
   * Maximum number of messages to return per page. Defaults to 100 if not provided. Larger values may impact performance.
   *
   * @format int64
   * @minimum 0
   */
  limit?: number;
  /**
   * Number of messages to skip for pagination. Defaults to 0 if not provided.
   *
   * @format int64
   * @minimum 0
   */
  offset?: number;
};

export type ChatMessagesError = Fetcher.ErrorWrapper<undefined>;

export type ChatMessagesVariables = {
  pathParams: ChatMessagesPathParams;
  queryParams?: ChatMessagesQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchChatMessages = (
  variables: ChatMessagesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.ChatMessagesResponse,
    ChatMessagesError,
    undefined,
    {},
    ChatMessagesQueryParams,
    ChatMessagesPathParams
  >({
    url: "/api/v1beta/chats/{chatId}/messages",
    method: "get",
    ...variables,
    signal,
  });

export function chatMessagesQuery(variables: ChatMessagesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ChatMessagesResponse>;
};

export function chatMessagesQuery(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ChatMessagesResponse>)
    | reactQuery.SkipToken;
};

export function chatMessagesQuery(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/chats/{chatId}/messages",
      operationId: "chatMessages",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchChatMessages(variables, signal),
  };
}

export const useSuspenseChatMessages = <TData = Schemas.ChatMessagesResponse,>(
  variables: ChatMessagesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChatMessagesResponse,
      ChatMessagesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ChatMessagesResponse,
    ChatMessagesError,
    TData
  >({
    ...chatMessagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useChatMessages = <TData = Schemas.ChatMessagesResponse,>(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChatMessagesResponse,
      ChatMessagesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.ChatMessagesResponse,
    ChatMessagesError,
    TData
  >({
    ...chatMessagesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetFilePathParams = {
  /**
   * The ID of the file to retrieve
   */
  fileId: string;
};

export type GetFileError = Fetcher.ErrorWrapper<undefined>;

export type GetFileVariables = {
  pathParams: GetFilePathParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export const fetchGetFile = (
  variables: GetFileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.FileUploadItem,
    GetFileError,
    undefined,
    {},
    {},
    GetFilePathParams
  >({ url: "/api/v1beta/files/{fileId}", method: "get", ...variables, signal });

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export function getFileQuery(variables: GetFileVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.FileUploadItem>;
};

export function getFileQuery(
  variables: GetFileVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.FileUploadItem>)
    | reactQuery.SkipToken;
};

export function getFileQuery(
  variables: GetFileVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/files/{fileId}",
      operationId: "getFile",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetFile(variables, signal),
  };
}

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export const useSuspenseGetFile = <TData = Schemas.FileUploadItem,>(
  variables: GetFileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FileUploadItem, GetFileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.FileUploadItem,
    GetFileError,
    TData
  >({
    ...getFileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export const useGetFile = <TData = Schemas.FileUploadItem,>(
  variables: GetFileVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FileUploadItem, GetFileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<Schemas.FileUploadItem, GetFileError, TData>({
    ...getFileQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CreateChatError = Fetcher.ErrorWrapper<undefined>;

export type CreateChatVariables = {
  body?: Schemas.CreateChatRequest;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint allows creating a new chat without requiring an initial message.
 * This is useful for scenarios where you want to upload files before sending the first message.
 */
export const fetchCreateChat = (
  variables: CreateChatVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.CreateChatResponse,
    CreateChatError,
    Schemas.CreateChatRequest,
    {},
    {},
    {}
  >({ url: "/api/v1beta/me/chats", method: "post", ...variables, signal });

/**
 * This endpoint allows creating a new chat without requiring an initial message.
 * This is useful for scenarios where you want to upload files before sending the first message.
 */
export const useCreateChat = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateChatResponse,
      CreateChatError,
      CreateChatVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.CreateChatResponse,
    CreateChatError,
    CreateChatVariables
  >({
    mutationFn: (variables: CreateChatVariables) =>
      fetchCreateChat(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UploadFileQueryParams = {
  /**
   * The chat ID to associate the file with.
   */
  chat_id: string;
};

export type UploadFileError = Fetcher.ErrorWrapper<undefined>;

export type UploadFileRequestBody = Schemas.MultipartFormFile[];

export type UploadFileVariables = {
  body?: UploadFileRequestBody;
  queryParams: UploadFileQueryParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint accepts a multipart form with one or more files and returns UUIDs for each.
 */
/**
 * WORKAROUND: This endpoint requires a multipart/form-data request.
 * Despite the type signature suggesting `body?: Schemas.MultipartFormFile[]`, 
 * the underlying fetcher expects a pre-constructed `FormData` object.
 * 
 * When calling this function, construct a `FormData` object manually,
 * append your file(s) to it (e.g., `formData.append('file', myFile)`),
 * and pass it as the `body` property in the `variables` object, using type casting:
 * 
 * ```ts
 * const formData = new FormData();
 * formData.append('file', myFile);
 * const variables = {
 *   queryParams: { chat_id: '...' },
 *   body: formData as unknown, // Cast needed to bypass type mismatch
 *   headers: { 'Content-Type': 'multipart/form-data' } // Header hint might be needed
 * };
 * const response = await fetchUploadFile(variables as UploadFileVariables);
 * ```
 */
export const fetchUploadFile = (
  variables: UploadFileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.FileUploadResponse,
    UploadFileError,
    UploadFileRequestBody,
    {},
    UploadFileQueryParams,
    {}
  >({ url: "/api/v1beta/me/files", method: "post", ...variables, signal });

/**
 * This endpoint accepts a multipart form with one or more files and returns UUIDs for each.
 */
export const useUploadFile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FileUploadResponse,
      UploadFileError,
      UploadFileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.FileUploadResponse,
    UploadFileError,
    UploadFileVariables
  >({
    mutationFn: (variables: UploadFileVariables) =>
      fetchUploadFile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type EditMessageSseError = Fetcher.ErrorWrapper<undefined>;

export type EditMessageSseVariables = {
  body: Schemas.EditMessageRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchEditMessageSse = (
  variables: EditMessageSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    EditMessageSseError,
    Schemas.EditMessageRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/editstream",
    method: "post",
    ...variables,
    signal,
  });

export const useEditMessageSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      EditMessageSseError,
      EditMessageSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    EditMessageSseError,
    EditMessageSseVariables
  >({
    mutationFn: (variables: EditMessageSseVariables) =>
      fetchEditMessageSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RegenerateMessageSseError = Fetcher.ErrorWrapper<undefined>;

export type RegenerateMessageSseVariables = {
  body: Schemas.RegenerateMessageRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchRegenerateMessageSse = (
  variables: RegenerateMessageSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    RegenerateMessageSseError,
    Schemas.RegenerateMessageRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/regeneratestream",
    method: "post",
    ...variables,
    signal,
  });

export const useRegenerateMessageSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RegenerateMessageSseError,
      RegenerateMessageSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    RegenerateMessageSseError,
    RegenerateMessageSseVariables
  >({
    mutationFn: (variables: RegenerateMessageSseVariables) =>
      fetchRegenerateMessageSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type MessageSubmitSseError = Fetcher.ErrorWrapper<undefined>;

export type MessageSubmitSseVariables = {
  body: Schemas.MessageSubmitRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchMessageSubmitSse = (
  variables: MessageSubmitSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    MessageSubmitSseError,
    Schemas.MessageSubmitRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/submitstream",
    method: "post",
    ...variables,
    signal,
  });

export const useMessageSubmitSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      MessageSubmitSseError,
      MessageSubmitSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    MessageSubmitSseError,
    MessageSubmitSseVariables
  >({
    mutationFn: (variables: MessageSubmitSseVariables) =>
      fetchMessageSubmitSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AvailableModelsError = Fetcher.ErrorWrapper<undefined>;

export type AvailableModelsResponse = Schemas.ChatModel[];

export type AvailableModelsVariables = V1betaApiContext["fetcherOptions"];

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export const fetchAvailableModels = (
  variables: AvailableModelsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    AvailableModelsResponse,
    AvailableModelsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1beta/me/models", method: "get", ...variables, signal });

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export function availableModelsQuery(variables: AvailableModelsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AvailableModelsResponse>;
};

export function availableModelsQuery(
  variables: AvailableModelsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AvailableModelsResponse>)
    | reactQuery.SkipToken;
};

export function availableModelsQuery(
  variables: AvailableModelsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/models",
      operationId: "availableModels",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAvailableModels(variables, signal),
  };
}

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export const useSuspenseAvailableModels = <TData = AvailableModelsResponse,>(
  variables: AvailableModelsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AvailableModelsResponse,
      AvailableModelsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    AvailableModelsResponse,
    AvailableModelsError,
    TData
  >({
    ...availableModelsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export const useAvailableModels = <TData = AvailableModelsResponse,>(
  variables: AvailableModelsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AvailableModelsResponse,
      AvailableModelsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    AvailableModelsResponse,
    AvailableModelsError,
    TData
  >({
    ...availableModelsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ProfileError = Fetcher.ErrorWrapper<undefined>;

export type ProfileVariables = V1betaApiContext["fetcherOptions"];

export const fetchProfile = (
  variables: ProfileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<Schemas.UserProfile, ProfileError, undefined, {}, {}, {}>({
    url: "/api/v1beta/me/profile",
    method: "get",
    ...variables,
    signal,
  });

export function profileQuery(variables: ProfileVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserProfile>;
};

export function profileQuery(
  variables: ProfileVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UserProfile>)
    | reactQuery.SkipToken;
};

export function profileQuery(
  variables: ProfileVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/profile",
      operationId: "profile",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchProfile(variables, signal),
  };
}

export const useSuspenseProfile = <TData = Schemas.UserProfile,>(
  variables: ProfileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, ProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<Schemas.UserProfile, ProfileError, TData>({
    ...profileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useProfile = <TData = Schemas.UserProfile,>(
  variables: ProfileVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, ProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<Schemas.UserProfile, ProfileError, TData>({
    ...profileQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RecentChatsQueryParams = {
  /**
   * Maximum number of chats to return per page. Defaults to 30 if not provided. Larger values may impact performance.
   *
   * @format int64
   * @minimum 0
   */
  limit?: number;
  /**
   * Number of chats to skip for pagination. Defaults to 0 if not provided.
   *
   * @format int64
   * @minimum 0
   */
  offset?: number;
  /**
   * Whether to include archived chats in results. Defaults to false if not provided.
   */
  include_archived?: boolean;
};

export type RecentChatsError = Fetcher.ErrorWrapper<undefined>;

export type RecentChatsVariables = {
  queryParams?: RecentChatsQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchRecentChats = (
  variables: RecentChatsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.RecentChatsResponse,
    RecentChatsError,
    undefined,
    {},
    RecentChatsQueryParams,
    {}
  >({
    url: "/api/v1beta/me/recent_chats",
    method: "get",
    ...variables,
    signal,
  });

export function recentChatsQuery(variables: RecentChatsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RecentChatsResponse>;
};

export function recentChatsQuery(
  variables: RecentChatsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RecentChatsResponse>)
    | reactQuery.SkipToken;
};

export function recentChatsQuery(
  variables: RecentChatsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/recent_chats",
      operationId: "recentChats",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchRecentChats(variables, signal),
  };
}

export const useSuspenseRecentChats = <TData = Schemas.RecentChatsResponse,>(
  variables: RecentChatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RecentChatsResponse,
      RecentChatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RecentChatsResponse,
    RecentChatsError,
    TData
  >({
    ...recentChatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecentChats = <TData = Schemas.RecentChatsResponse,>(
  variables: RecentChatsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RecentChatsResponse,
      RecentChatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.RecentChatsResponse,
    RecentChatsError,
    TData
  >({
    ...recentChatsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MessagesError = Fetcher.ErrorWrapper<undefined>;

export type MessagesResponse = Schemas.Message[];

export type MessagesVariables = V1betaApiContext["fetcherOptions"];

export const fetchMessages = (
  variables: MessagesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<MessagesResponse, MessagesError, undefined, {}, {}, {}>({
    url: "/api/v1beta/messages",
    method: "get",
    ...variables,
    signal,
  });

export function messagesQuery(variables: MessagesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MessagesResponse>;
};

export function messagesQuery(
  variables: MessagesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MessagesResponse>)
    | reactQuery.SkipToken;
};

export function messagesQuery(
  variables: MessagesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/messages",
      operationId: "messages",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchMessages(variables, signal),
  };
}

export const useSuspenseMessages = <TData = MessagesResponse,>(
  variables: MessagesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<MessagesResponse, MessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<MessagesResponse, MessagesError, TData>({
    ...messagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMessages = <TData = MessagesResponse,>(
  variables: MessagesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<MessagesResponse, MessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<MessagesResponse, MessagesError, TData>({
    ...messagesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type TokenUsageEstimateError = Fetcher.ErrorWrapper<undefined>;

export type TokenUsageEstimateVariables = {
  body: Schemas.TokenUsageRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchTokenUsageEstimate = (
  variables: TokenUsageEstimateVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.TokenUsageResponse,
    TokenUsageEstimateError,
    Schemas.TokenUsageRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/token_usage/estimate",
    method: "post",
    ...variables,
    signal,
  });

export const useTokenUsageEstimate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenUsageResponse,
      TokenUsageEstimateError,
      TokenUsageEstimateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.TokenUsageResponse,
    TokenUsageEstimateError,
    TokenUsageEstimateVariables
  >({
    mutationFn: (variables: TokenUsageEstimateVariables) =>
      fetchTokenUsageEstimate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HealthError = Fetcher.ErrorWrapper<undefined>;

export type HealthVariables = V1betaApiContext["fetcherOptions"];

export const fetchHealth = (variables: HealthVariables, signal?: AbortSignal) =>
  v1betaApiFetch<undefined, HealthError, undefined, {}, {}, {}>({
    url: "/health",
    method: "get",
    ...variables,
    signal,
  });

export function healthQuery(variables: HealthVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function healthQuery(
  variables: HealthVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function healthQuery(variables: HealthVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/health",
      operationId: "health",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchHealth(variables, signal),
  };
}

export const useSuspenseHealth = <TData = undefined,>(
  variables: HealthVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, HealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<undefined, HealthError, TData>({
    ...healthQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useHealth = <TData = undefined,>(
  variables: HealthVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, HealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<undefined, HealthError, TData>({
    ...healthQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/v1beta/chats";
      operationId: "chats";
      variables: ChatsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/chats/{chatId}/messages";
      operationId: "chatMessages";
      variables: ChatMessagesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/files/{fileId}";
      operationId: "getFile";
      variables: GetFileVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/models";
      operationId: "availableModels";
      variables: AvailableModelsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/profile";
      operationId: "profile";
      variables: ProfileVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/recent_chats";
      operationId: "recentChats";
      variables: RecentChatsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/messages";
      operationId: "messages";
      variables: MessagesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/health";
      operationId: "health";
      variables: HealthVariables | reactQuery.SkipToken;
    };

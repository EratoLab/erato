/**
 * Generated by @openapi-codegen
 *
 * @version
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useV1betaApiContext,
  V1betaApiContext,
  queryKeyFn,
} from "./v1betaApiContext";
import { deepMerge } from "./v1betaApiUtils";
import type * as Fetcher from "./v1betaApiFetcher";
import { v1betaApiFetch } from "./v1betaApiFetcher";
import type * as Schemas from "./v1betaApiSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type ListAssistantsQueryParams = {
  /**
   * Filter assistants by sharing relation
   * - `all` (default): All assistants are listed
   * - `owned_by_user`: Only assistants owned by the user
   * - `shared_with_user`: Only assistants shared with the user (= all - owned_by_user)
   */
  sharing_relation?: string;
};

export type ListAssistantsError = Fetcher.ErrorWrapper<undefined>;

export type ListAssistantsResponse = Schemas.Assistant[];

export type ListAssistantsVariables = {
  queryParams?: ListAssistantsQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchListAssistants = (
  variables: ListAssistantsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    ListAssistantsResponse,
    ListAssistantsError,
    undefined,
    {},
    ListAssistantsQueryParams,
    {}
  >({ url: "/api/v1beta/assistants", method: "get", ...variables, signal });

export function listAssistantsQuery(variables: ListAssistantsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ListAssistantsResponse>;
};

export function listAssistantsQuery(
  variables: ListAssistantsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<ListAssistantsResponse>)
    | reactQuery.SkipToken;
};

export function listAssistantsQuery(
  variables: ListAssistantsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/assistants",
      operationId: "listAssistants",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchListAssistants(variables, signal),
  };
}

export const useSuspenseListAssistants = <TData = ListAssistantsResponse,>(
  variables: ListAssistantsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListAssistantsResponse,
      ListAssistantsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    ListAssistantsResponse,
    ListAssistantsError,
    TData
  >({
    ...listAssistantsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useListAssistants = <TData = ListAssistantsResponse,>(
  variables: ListAssistantsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListAssistantsResponse,
      ListAssistantsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    ListAssistantsResponse,
    ListAssistantsError,
    TData
  >({
    ...listAssistantsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CreateAssistantError = Fetcher.ErrorWrapper<undefined>;

export type CreateAssistantVariables = {
  body: Schemas.CreateAssistantRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchCreateAssistant = (
  variables: CreateAssistantVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.AssistantWithFiles,
    CreateAssistantError,
    Schemas.CreateAssistantRequest,
    {},
    {},
    {}
  >({ url: "/api/v1beta/assistants", method: "post", ...variables, signal });

export const useCreateAssistant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AssistantWithFiles,
      CreateAssistantError,
      CreateAssistantVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.AssistantWithFiles,
    CreateAssistantError,
    CreateAssistantVariables
  >({
    mutationFn: (variables: CreateAssistantVariables) =>
      fetchCreateAssistant(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAssistantPathParams = {
  /**
   * The ID of the assistant to retrieve
   */
  assistantId: string;
};

export type GetAssistantError = Fetcher.ErrorWrapper<undefined>;

export type GetAssistantVariables = {
  pathParams: GetAssistantPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchGetAssistant = (
  variables: GetAssistantVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.AssistantWithFiles,
    GetAssistantError,
    undefined,
    {},
    {},
    GetAssistantPathParams
  >({
    url: "/api/v1beta/assistants/{assistantId}",
    method: "get",
    ...variables,
    signal,
  });

export function getAssistantQuery(variables: GetAssistantVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.AssistantWithFiles>;
};

export function getAssistantQuery(
  variables: GetAssistantVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.AssistantWithFiles>)
    | reactQuery.SkipToken;
};

export function getAssistantQuery(
  variables: GetAssistantVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/assistants/{assistantId}",
      operationId: "getAssistant",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetAssistant(variables, signal),
  };
}

export const useSuspenseGetAssistant = <TData = Schemas.AssistantWithFiles,>(
  variables: GetAssistantVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AssistantWithFiles,
      GetAssistantError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.AssistantWithFiles,
    GetAssistantError,
    TData
  >({
    ...getAssistantQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAssistant = <TData = Schemas.AssistantWithFiles,>(
  variables: GetAssistantVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AssistantWithFiles,
      GetAssistantError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.AssistantWithFiles,
    GetAssistantError,
    TData
  >({
    ...getAssistantQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateAssistantPathParams = {
  /**
   * The ID of the assistant to update
   */
  assistantId: string;
};

export type UpdateAssistantError = Fetcher.ErrorWrapper<undefined>;

export type UpdateAssistantVariables = {
  body?: Schemas.UpdateAssistantRequest;
  pathParams: UpdateAssistantPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchUpdateAssistant = (
  variables: UpdateAssistantVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.AssistantWithFiles,
    UpdateAssistantError,
    Schemas.UpdateAssistantRequest,
    {},
    {},
    UpdateAssistantPathParams
  >({
    url: "/api/v1beta/assistants/{assistantId}",
    method: "put",
    ...variables,
    signal,
  });

export const useUpdateAssistant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AssistantWithFiles,
      UpdateAssistantError,
      UpdateAssistantVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.AssistantWithFiles,
    UpdateAssistantError,
    UpdateAssistantVariables
  >({
    mutationFn: (variables: UpdateAssistantVariables) =>
      fetchUpdateAssistant(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ArchiveAssistantPathParams = {
  /**
   * The ID of the assistant to archive
   */
  assistantId: string;
};

export type ArchiveAssistantError = Fetcher.ErrorWrapper<undefined>;

export type ArchiveAssistantVariables = {
  body?: Schemas.ArchiveAssistantRequest;
  pathParams: ArchiveAssistantPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchArchiveAssistant = (
  variables: ArchiveAssistantVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.ArchiveAssistantResponse,
    ArchiveAssistantError,
    Schemas.ArchiveAssistantRequest,
    {},
    {},
    ArchiveAssistantPathParams
  >({
    url: "/api/v1beta/assistants/{assistantId}/archive",
    method: "post",
    ...variables,
    signal,
  });

export const useArchiveAssistant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ArchiveAssistantResponse,
      ArchiveAssistantError,
      ArchiveAssistantVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.ArchiveAssistantResponse,
    ArchiveAssistantError,
    ArchiveAssistantVariables
  >({
    mutationFn: (variables: ArchiveAssistantVariables) =>
      fetchArchiveAssistant(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ChatsError = Fetcher.ErrorWrapper<undefined>;

export type ChatsResponse = Schemas.Chat[];

export type ChatsVariables = V1betaApiContext["fetcherOptions"];

export const fetchChats = (variables: ChatsVariables, signal?: AbortSignal) =>
  v1betaApiFetch<ChatsResponse, ChatsError, undefined, {}, {}, {}>({
    url: "/api/v1beta/chats",
    method: "get",
    ...variables,
    signal,
  });

export function chatsQuery(variables: ChatsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ChatsResponse>;
};

export function chatsQuery(variables: ChatsVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<ChatsResponse>)
    | reactQuery.SkipToken;
};

export function chatsQuery(variables: ChatsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/chats",
      operationId: "chats",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchChats(variables, signal),
  };
}

export const useSuspenseChats = <TData = ChatsResponse,>(
  variables: ChatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatsResponse, ChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<ChatsResponse, ChatsError, TData>({
    ...chatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useChats = <TData = ChatsResponse,>(
  variables: ChatsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<ChatsResponse, ChatsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<ChatsResponse, ChatsError, TData>({
    ...chatsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArchiveChatEndpointPathParams = {
  /**
   * The ID of the chat to archive
   */
  chatId: string;
};

export type ArchiveChatEndpointError = Fetcher.ErrorWrapper<undefined>;

export type ArchiveChatEndpointVariables = {
  body?: Schemas.ArchiveChatRequest;
  pathParams: ArchiveChatEndpointPathParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint marks a chat as archived by setting its archived_at timestamp.
 * Archived chats can be filtered out from the recent chats listing by default.
 */
export const fetchArchiveChatEndpoint = (
  variables: ArchiveChatEndpointVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.ArchiveChatResponse,
    ArchiveChatEndpointError,
    Schemas.ArchiveChatRequest,
    {},
    {},
    ArchiveChatEndpointPathParams
  >({
    url: "/api/v1beta/chats/{chatId}/archive",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint marks a chat as archived by setting its archived_at timestamp.
 * Archived chats can be filtered out from the recent chats listing by default.
 */
export const useArchiveChatEndpoint = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ArchiveChatResponse,
      ArchiveChatEndpointError,
      ArchiveChatEndpointVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.ArchiveChatResponse,
    ArchiveChatEndpointError,
    ArchiveChatEndpointVariables
  >({
    mutationFn: (variables: ArchiveChatEndpointVariables) =>
      fetchArchiveChatEndpoint(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ChatMessagesPathParams = {
  /**
   * The ID of the chat to get messages for
   */
  chatId: string;
};

export type ChatMessagesQueryParams = {
  /**
   * Maximum number of messages to return per page. Defaults to 100 if not provided. Larger values may impact performance.
   *
   * @format int64
   * @minimum 0
   */
  limit?: number;
  /**
   * Number of messages to skip for pagination. Defaults to 0 if not provided.
   *
   * @format int64
   * @minimum 0
   */
  offset?: number;
};

export type ChatMessagesError = Fetcher.ErrorWrapper<undefined>;

export type ChatMessagesVariables = {
  pathParams: ChatMessagesPathParams;
  queryParams?: ChatMessagesQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchChatMessages = (
  variables: ChatMessagesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.ChatMessagesResponse,
    ChatMessagesError,
    undefined,
    {},
    ChatMessagesQueryParams,
    ChatMessagesPathParams
  >({
    url: "/api/v1beta/chats/{chatId}/messages",
    method: "get",
    ...variables,
    signal,
  });

export function chatMessagesQuery(variables: ChatMessagesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ChatMessagesResponse>;
};

export function chatMessagesQuery(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ChatMessagesResponse>)
    | reactQuery.SkipToken;
};

export function chatMessagesQuery(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/chats/{chatId}/messages",
      operationId: "chatMessages",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchChatMessages(variables, signal),
  };
}

export const useSuspenseChatMessages = <TData = Schemas.ChatMessagesResponse,>(
  variables: ChatMessagesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChatMessagesResponse,
      ChatMessagesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ChatMessagesResponse,
    ChatMessagesError,
    TData
  >({
    ...chatMessagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useChatMessages = <TData = Schemas.ChatMessagesResponse,>(
  variables: ChatMessagesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChatMessagesResponse,
      ChatMessagesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.ChatMessagesResponse,
    ChatMessagesError,
    TData
  >({
    ...chatMessagesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetFilePathParams = {
  /**
   * The ID of the file to retrieve
   */
  fileId: string;
};

export type GetFileError = Fetcher.ErrorWrapper<undefined>;

export type GetFileVariables = {
  pathParams: GetFilePathParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export const fetchGetFile = (
  variables: GetFileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.FileUploadItem,
    GetFileError,
    undefined,
    {},
    {},
    GetFilePathParams
  >({ url: "/api/v1beta/files/{fileId}", method: "get", ...variables, signal });

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export function getFileQuery(variables: GetFileVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.FileUploadItem>;
};

export function getFileQuery(
  variables: GetFileVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.FileUploadItem>)
    | reactQuery.SkipToken;
};

export function getFileQuery(
  variables: GetFileVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/files/{fileId}",
      operationId: "getFile",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetFile(variables, signal),
  };
}

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export const useSuspenseGetFile = <TData = Schemas.FileUploadItem,>(
  variables: GetFileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FileUploadItem, GetFileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.FileUploadItem,
    GetFileError,
    TData
  >({
    ...getFileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This endpoint retrieves information about a specific file by its ID.
 */
export const useGetFile = <TData = Schemas.FileUploadItem,>(
  variables: GetFileVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FileUploadItem, GetFileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<Schemas.FileUploadItem, GetFileError, TData>({
    ...getFileQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AllDrivesError = Fetcher.ErrorWrapper<undefined>;

export type AllDrivesVariables = V1betaApiContext["fetcherOptions"];

/**
 * This includes:
 * - The user's personal OneDrive
 * - Drives shared with the user
 * - Recent items (as a pseudo-drive)
 */
export const fetchAllDrives = (
  variables: AllDrivesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.AllDrivesResponse,
    AllDrivesError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/integrations/sharepoint/all-drives",
    method: "get",
    ...variables,
    signal,
  });

/**
 * This includes:
 * - The user's personal OneDrive
 * - Drives shared with the user
 * - Recent items (as a pseudo-drive)
 */
export function allDrivesQuery(variables: AllDrivesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.AllDrivesResponse>;
};

export function allDrivesQuery(
  variables: AllDrivesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.AllDrivesResponse>)
    | reactQuery.SkipToken;
};

export function allDrivesQuery(
  variables: AllDrivesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/integrations/sharepoint/all-drives",
      operationId: "allDrives",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAllDrives(variables, signal),
  };
}

/**
 * This includes:
 * - The user's personal OneDrive
 * - Drives shared with the user
 * - Recent items (as a pseudo-drive)
 */
export const useSuspenseAllDrives = <TData = Schemas.AllDrivesResponse,>(
  variables: AllDrivesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AllDrivesResponse,
      AllDrivesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.AllDrivesResponse,
    AllDrivesError,
    TData
  >({
    ...allDrivesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This includes:
 * - The user's personal OneDrive
 * - Drives shared with the user
 * - Recent items (as a pseudo-drive)
 */
export const useAllDrives = <TData = Schemas.AllDrivesResponse,>(
  variables: AllDrivesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AllDrivesResponse,
      AllDrivesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<Schemas.AllDrivesResponse, AllDrivesError, TData>({
    ...allDrivesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetDriveRootPathParams = {
  /**
   * The ID of the drive
   */
  driveId: string;
};

export type GetDriveRootError = Fetcher.ErrorWrapper<undefined>;

export type GetDriveRootVariables = {
  pathParams: GetDriveRootPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchGetDriveRoot = (
  variables: GetDriveRootVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.DriveItemsResponse,
    GetDriveRootError,
    undefined,
    {},
    {},
    GetDriveRootPathParams
  >({
    url: "/api/v1beta/integrations/sharepoint/drives/{driveId}",
    method: "get",
    ...variables,
    signal,
  });

export function getDriveRootQuery(variables: GetDriveRootVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.DriveItemsResponse>;
};

export function getDriveRootQuery(
  variables: GetDriveRootVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.DriveItemsResponse>)
    | reactQuery.SkipToken;
};

export function getDriveRootQuery(
  variables: GetDriveRootVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/integrations/sharepoint/drives/{driveId}",
      operationId: "getDriveRoot",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetDriveRoot(variables, signal),
  };
}

export const useSuspenseGetDriveRoot = <TData = Schemas.DriveItemsResponse,>(
  variables: GetDriveRootVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.DriveItemsResponse,
      GetDriveRootError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.DriveItemsResponse,
    GetDriveRootError,
    TData
  >({
    ...getDriveRootQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetDriveRoot = <TData = Schemas.DriveItemsResponse,>(
  variables: GetDriveRootVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.DriveItemsResponse,
      GetDriveRootError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.DriveItemsResponse,
    GetDriveRootError,
    TData
  >({
    ...getDriveRootQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetDriveItemPathParams = {
  /**
   * The ID of the drive
   */
  driveId: string;
  /**
   * The ID of the item
   */
  itemId: string;
};

export type GetDriveItemError = Fetcher.ErrorWrapper<undefined>;

export type GetDriveItemVariables = {
  pathParams: GetDriveItemPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchGetDriveItem = (
  variables: GetDriveItemVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.DriveItemResponse,
    GetDriveItemError,
    undefined,
    {},
    {},
    GetDriveItemPathParams
  >({
    url: "/api/v1beta/integrations/sharepoint/drives/{driveId}/items/{itemId}",
    method: "get",
    ...variables,
    signal,
  });

export function getDriveItemQuery(variables: GetDriveItemVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.DriveItemResponse>;
};

export function getDriveItemQuery(
  variables: GetDriveItemVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.DriveItemResponse>)
    | reactQuery.SkipToken;
};

export function getDriveItemQuery(
  variables: GetDriveItemVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/integrations/sharepoint/drives/{driveId}/items/{itemId}",
      operationId: "getDriveItem",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetDriveItem(variables, signal),
  };
}

export const useSuspenseGetDriveItem = <TData = Schemas.DriveItemResponse,>(
  variables: GetDriveItemVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.DriveItemResponse,
      GetDriveItemError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.DriveItemResponse,
    GetDriveItemError,
    TData
  >({
    ...getDriveItemQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetDriveItem = <TData = Schemas.DriveItemResponse,>(
  variables: GetDriveItemVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.DriveItemResponse,
      GetDriveItemError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.DriveItemResponse,
    GetDriveItemError,
    TData
  >({
    ...getDriveItemQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetDriveItemChildrenPathParams = {
  /**
   * The ID of the drive
   */
  driveId: string;
  /**
   * The ID of the folder
   */
  itemId: string;
};

export type GetDriveItemChildrenError = Fetcher.ErrorWrapper<undefined>;

export type GetDriveItemChildrenVariables = {
  pathParams: GetDriveItemChildrenPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchGetDriveItemChildren = (
  variables: GetDriveItemChildrenVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.DriveItemsResponse,
    GetDriveItemChildrenError,
    undefined,
    {},
    {},
    GetDriveItemChildrenPathParams
  >({
    url: "/api/v1beta/integrations/sharepoint/drives/{driveId}/items/{itemId}/children",
    method: "get",
    ...variables,
    signal,
  });

export function getDriveItemChildrenQuery(
  variables: GetDriveItemChildrenVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.DriveItemsResponse>;
};

export function getDriveItemChildrenQuery(
  variables: GetDriveItemChildrenVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.DriveItemsResponse>)
    | reactQuery.SkipToken;
};

export function getDriveItemChildrenQuery(
  variables: GetDriveItemChildrenVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/integrations/sharepoint/drives/{driveId}/items/{itemId}/children",
      operationId: "getDriveItemChildren",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetDriveItemChildren(variables, signal),
  };
}

export const useSuspenseGetDriveItemChildren = <
  TData = Schemas.DriveItemsResponse,
>(
  variables: GetDriveItemChildrenVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.DriveItemsResponse,
      GetDriveItemChildrenError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.DriveItemsResponse,
    GetDriveItemChildrenError,
    TData
  >({
    ...getDriveItemChildrenQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetDriveItemChildren = <TData = Schemas.DriveItemsResponse,>(
  variables: GetDriveItemChildrenVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.DriveItemsResponse,
      GetDriveItemChildrenError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.DriveItemsResponse,
    GetDriveItemChildrenError,
    TData
  >({
    ...getDriveItemChildrenQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type BudgetStatusError = Fetcher.ErrorWrapper<undefined>;

export type BudgetStatusVariables = V1betaApiContext["fetcherOptions"];

export const fetchBudgetStatus = (
  variables: BudgetStatusVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.BudgetStatusResponse,
    BudgetStatusError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1beta/me/budget", method: "get", ...variables, signal });

export function budgetStatusQuery(variables: BudgetStatusVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.BudgetStatusResponse>;
};

export function budgetStatusQuery(
  variables: BudgetStatusVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.BudgetStatusResponse>)
    | reactQuery.SkipToken;
};

export function budgetStatusQuery(
  variables: BudgetStatusVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/budget",
      operationId: "budgetStatus",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchBudgetStatus(variables, signal),
  };
}

export const useSuspenseBudgetStatus = <TData = Schemas.BudgetStatusResponse,>(
  variables: BudgetStatusVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BudgetStatusResponse,
      BudgetStatusError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.BudgetStatusResponse,
    BudgetStatusError,
    TData
  >({
    ...budgetStatusQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useBudgetStatus = <TData = Schemas.BudgetStatusResponse,>(
  variables: BudgetStatusVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BudgetStatusResponse,
      BudgetStatusError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.BudgetStatusResponse,
    BudgetStatusError,
    TData
  >({
    ...budgetStatusQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CreateChatError = Fetcher.ErrorWrapper<undefined>;

export type CreateChatVariables = {
  body?: Schemas.CreateChatRequest;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint allows creating a new chat without requiring an initial message.
 * This is useful for scenarios where you want to upload files before sending the first message.
 */
export const fetchCreateChat = (
  variables: CreateChatVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.CreateChatResponse,
    CreateChatError,
    Schemas.CreateChatRequest,
    {},
    {},
    {}
  >({ url: "/api/v1beta/me/chats", method: "post", ...variables, signal });

/**
 * This endpoint allows creating a new chat without requiring an initial message.
 * This is useful for scenarios where you want to upload files before sending the first message.
 */
export const useCreateChat = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateChatResponse,
      CreateChatError,
      CreateChatVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.CreateChatResponse,
    CreateChatError,
    CreateChatVariables
  >({
    mutationFn: (variables: CreateChatVariables) =>
      fetchCreateChat(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ArchiveAllChatsEndpointError = Fetcher.ErrorWrapper<undefined>;

export type ArchiveAllChatsEndpointVariables =
  V1betaApiContext["fetcherOptions"];

/**
 * Only chats that are currently not archived are updated.
 * Previously archived chats keep their original `archived_at` timestamp.
 */
export const fetchArchiveAllChatsEndpoint = (
  variables: ArchiveAllChatsEndpointVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.ArchiveAllChatsResponse,
    ArchiveAllChatsEndpointError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/chats/archive_all",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Only chats that are currently not archived are updated.
 * Previously archived chats keep their original `archived_at` timestamp.
 */
export const useArchiveAllChatsEndpoint = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ArchiveAllChatsResponse,
      ArchiveAllChatsEndpointError,
      ArchiveAllChatsEndpointVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.ArchiveAllChatsResponse,
    ArchiveAllChatsEndpointError,
    ArchiveAllChatsEndpointVariables
  >({
    mutationFn: (variables: ArchiveAllChatsEndpointVariables) =>
      fetchArchiveAllChatsEndpoint(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UpdateChatPathParams = {
  /**
   * The ID of the chat to update
   */
  chatId: string;
};

export type UpdateChatError = Fetcher.ErrorWrapper<undefined>;

export type UpdateChatVariables = {
  body?: Schemas.UpdateChatRequest;
  pathParams: UpdateChatPathParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * Currently supports updating only `title_by_user_provided`.
 */
export const fetchUpdateChat = (
  variables: UpdateChatVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.UpdateChatResponse,
    UpdateChatError,
    Schemas.UpdateChatRequest,
    {},
    {},
    UpdateChatPathParams
  >({
    url: "/api/v1beta/me/chats/{chatId}",
    method: "put",
    ...variables,
    signal,
  });

/**
 * Currently supports updating only `title_by_user_provided`.
 */
export const useUpdateChat = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UpdateChatResponse,
      UpdateChatError,
      UpdateChatVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.UpdateChatResponse,
    UpdateChatError,
    UpdateChatVariables
  >({
    mutationFn: (variables: UpdateChatVariables) =>
      fetchUpdateChat(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FacetsError = Fetcher.ErrorWrapper<undefined>;

export type FacetsVariables = V1betaApiContext["fetcherOptions"];

export const fetchFacets = (variables: FacetsVariables, signal?: AbortSignal) =>
  v1betaApiFetch<Schemas.FacetsResponse, FacetsError, undefined, {}, {}, {}>({
    url: "/api/v1beta/me/facets",
    method: "get",
    ...variables,
    signal,
  });

export function facetsQuery(variables: FacetsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.FacetsResponse>;
};

export function facetsQuery(
  variables: FacetsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.FacetsResponse>)
    | reactQuery.SkipToken;
};

export function facetsQuery(variables: FacetsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/facets",
      operationId: "facets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchFacets(variables, signal),
  };
}

export const useSuspenseFacets = <TData = Schemas.FacetsResponse,>(
  variables: FacetsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FacetsResponse, FacetsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.FacetsResponse,
    FacetsError,
    TData
  >({
    ...facetsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFacets = <TData = Schemas.FacetsResponse,>(
  variables: FacetsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.FacetsResponse, FacetsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<Schemas.FacetsResponse, FacetsError, TData>({
    ...facetsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FileCapabilitiesQueryParams = {
  /**
   * Optional model ID to get capabilities specific to that model
   */
  model_id?: string;
};

export type FileCapabilitiesError = Fetcher.ErrorWrapper<undefined>;

export type FileCapabilitiesResponse = Schemas.FileCapability[];

export type FileCapabilitiesVariables = {
  queryParams?: FileCapabilitiesQueryParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint returns all available file capabilities based on the configured
 * file processors and model capabilities. An optional model_id can be provided
 * to get capabilities specific to that model (particularly for image understanding).
 */
export const fetchFileCapabilities = (
  variables: FileCapabilitiesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    FileCapabilitiesResponse,
    FileCapabilitiesError,
    undefined,
    {},
    FileCapabilitiesQueryParams,
    {}
  >({
    url: "/api/v1beta/me/file-capabilities",
    method: "get",
    ...variables,
    signal,
  });

/**
 * This endpoint returns all available file capabilities based on the configured
 * file processors and model capabilities. An optional model_id can be provided
 * to get capabilities specific to that model (particularly for image understanding).
 */
export function fileCapabilitiesQuery(variables: FileCapabilitiesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<FileCapabilitiesResponse>;
};

export function fileCapabilitiesQuery(
  variables: FileCapabilitiesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<FileCapabilitiesResponse>)
    | reactQuery.SkipToken;
};

export function fileCapabilitiesQuery(
  variables: FileCapabilitiesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/file-capabilities",
      operationId: "fileCapabilities",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFileCapabilities(variables, signal),
  };
}

/**
 * This endpoint returns all available file capabilities based on the configured
 * file processors and model capabilities. An optional model_id can be provided
 * to get capabilities specific to that model (particularly for image understanding).
 */
export const useSuspenseFileCapabilities = <TData = FileCapabilitiesResponse,>(
  variables: FileCapabilitiesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FileCapabilitiesResponse,
      FileCapabilitiesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    FileCapabilitiesResponse,
    FileCapabilitiesError,
    TData
  >({
    ...fileCapabilitiesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This endpoint returns all available file capabilities based on the configured
 * file processors and model capabilities. An optional model_id can be provided
 * to get capabilities specific to that model (particularly for image understanding).
 */
export const useFileCapabilities = <TData = FileCapabilitiesResponse,>(
  variables: FileCapabilitiesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FileCapabilitiesResponse,
      FileCapabilitiesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    FileCapabilitiesResponse,
    FileCapabilitiesError,
    TData
  >({
    ...fileCapabilitiesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UploadFileQueryParams = {
  /**
   * Optional chat ID to associate the file with. If not provided, creates standalone files.
   */
  chat_id?: string;
};

export type UploadFileError = Fetcher.ErrorWrapper<undefined>;

export type UploadFileRequestBody = Schemas.MultipartFormFile[];

export type UploadFileVariables = {
  body?: UploadFileRequestBody;
  queryParams?: UploadFileQueryParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint accepts a multipart form with one or more files and returns UUIDs for each.
 * If chat_id is provided, files are associated with that chat. If not provided, files are created
 * as standalone uploads that can be linked to assistants later.
 */
/**
 * WORKAROUND: This endpoint requires a multipart/form-data request.
 * Despite the type signature suggesting `body?: Schemas.MultipartFormFile[]`, 
 * the underlying fetcher expects a pre-constructed `FormData` object.
 * 
 * When calling this function, construct a `FormData` object manually,
 * append your file(s) to it (e.g., `formData.append('file', myFile)`),
 * and pass it as the `body` property in the `variables` object, using type casting:
 * 
 * ```ts
 * const formData = new FormData();
 * formData.append('file', myFile);
 * const variables = {
 *   queryParams: { chat_id: '...' },
 *   body: formData as unknown, // Cast needed to bypass type mismatch
 *   headers: { 'Content-Type': 'multipart/form-data' } // Header hint might be needed
 * };
 * const response = await fetchUploadFile(variables as UploadFileVariables);
 * ```
 */
export const fetchUploadFile = (
  variables: UploadFileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.FileUploadResponse,
    UploadFileError,
    UploadFileRequestBody,
    {},
    UploadFileQueryParams,
    {}
  >({ url: "/api/v1beta/me/files", method: "post", ...variables, signal });

/**
 * This endpoint accepts a multipart form with one or more files and returns UUIDs for each.
 * If chat_id is provided, files are associated with that chat. If not provided, files are created
 * as standalone uploads that can be linked to assistants later.
 */
export const useUploadFile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FileUploadResponse,
      UploadFileError,
      UploadFileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.FileUploadResponse,
    UploadFileError,
    UploadFileVariables
  >({
    mutationFn: (variables: UploadFileVariables) =>
      fetchUploadFile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type LinkFileError = Fetcher.ErrorWrapper<undefined>;

export type LinkFileVariables = {
  body: Schemas.LinkFileRequest;
} & V1betaApiContext["fetcherOptions"];

/**
 * This endpoint creates a file upload record that references an external file,
 * allowing it to be used in chat messages or attached to assistants.
 * If chat_id is provided, the file is associated with that chat. If not provided,
 * the file is created as a standalone upload.
 */
export const fetchLinkFile = (
  variables: LinkFileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.FileUploadResponse,
    LinkFileError,
    Schemas.LinkFileRequest,
    {},
    {},
    {}
  >({ url: "/api/v1beta/me/files/link", method: "post", ...variables, signal });

/**
 * This endpoint creates a file upload record that references an external file,
 * allowing it to be used in chat messages or attached to assistants.
 * If chat_id is provided, the file is associated with that chat. If not provided,
 * the file is created as a standalone upload.
 */
export const useLinkFile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FileUploadResponse,
      LinkFileError,
      LinkFileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.FileUploadResponse,
    LinkFileError,
    LinkFileVariables
  >({
    mutationFn: (variables: LinkFileVariables) =>
      fetchLinkFile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FrequentAssistantsQueryParams = {
  /**
   * Maximum number of assistants to return. Defaults to 10 if not provided.
   *
   * @format int64
   * @minimum 0
   */
  limit?: number;
  /**
   * Number of days to look back for usage statistics. Defaults to 30 if not provided.
   *
   * @format int32
   * @minimum 0
   */
  days?: number;
};

export type FrequentAssistantsError = Fetcher.ErrorWrapper<undefined>;

export type FrequentAssistantsVariables = {
  queryParams?: FrequentAssistantsQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchFrequentAssistants = (
  variables: FrequentAssistantsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.FrequentAssistantsResponse,
    FrequentAssistantsError,
    undefined,
    {},
    FrequentAssistantsQueryParams,
    {}
  >({
    url: "/api/v1beta/me/frequent_assistants",
    method: "get",
    ...variables,
    signal,
  });

export function frequentAssistantsQuery(
  variables: FrequentAssistantsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.FrequentAssistantsResponse>;
};

export function frequentAssistantsQuery(
  variables: FrequentAssistantsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.FrequentAssistantsResponse>)
    | reactQuery.SkipToken;
};

export function frequentAssistantsQuery(
  variables: FrequentAssistantsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/frequent_assistants",
      operationId: "frequentAssistants",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFrequentAssistants(variables, signal),
  };
}

export const useSuspenseFrequentAssistants = <
  TData = Schemas.FrequentAssistantsResponse,
>(
  variables: FrequentAssistantsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FrequentAssistantsResponse,
      FrequentAssistantsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.FrequentAssistantsResponse,
    FrequentAssistantsError,
    TData
  >({
    ...frequentAssistantsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFrequentAssistants = <
  TData = Schemas.FrequentAssistantsResponse,
>(
  variables: FrequentAssistantsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FrequentAssistantsResponse,
      FrequentAssistantsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.FrequentAssistantsResponse,
    FrequentAssistantsError,
    TData
  >({
    ...frequentAssistantsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type EditMessageSseError = Fetcher.ErrorWrapper<undefined>;

export type EditMessageSseVariables = {
  body: Schemas.EditMessageRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchEditMessageSse = (
  variables: EditMessageSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    EditMessageSseError,
    Schemas.EditMessageRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/editstream",
    method: "post",
    ...variables,
    signal,
  });

export const useEditMessageSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      EditMessageSseError,
      EditMessageSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    EditMessageSseError,
    EditMessageSseVariables
  >({
    mutationFn: (variables: EditMessageSseVariables) =>
      fetchEditMessageSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RegenerateMessageSseError = Fetcher.ErrorWrapper<undefined>;

export type RegenerateMessageSseVariables = {
  body: Schemas.RegenerateMessageRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchRegenerateMessageSse = (
  variables: RegenerateMessageSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    RegenerateMessageSseError,
    Schemas.RegenerateMessageRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/regeneratestream",
    method: "post",
    ...variables,
    signal,
  });

export const useRegenerateMessageSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RegenerateMessageSseError,
      RegenerateMessageSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    RegenerateMessageSseError,
    RegenerateMessageSseVariables
  >({
    mutationFn: (variables: RegenerateMessageSseVariables) =>
      fetchRegenerateMessageSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ResumeMessageSseError = Fetcher.ErrorWrapper<undefined>;

export type ResumeMessageSseVariables = {
  body: Schemas.ResumeStreamRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchResumeMessageSse = (
  variables: ResumeMessageSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    ResumeMessageSseError,
    Schemas.ResumeStreamRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/resumestream",
    method: "post",
    ...variables,
    signal,
  });

export const useResumeMessageSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ResumeMessageSseError,
      ResumeMessageSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    ResumeMessageSseError,
    ResumeMessageSseVariables
  >({
    mutationFn: (variables: ResumeMessageSseVariables) =>
      fetchResumeMessageSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type MessageSubmitSseError = Fetcher.ErrorWrapper<undefined>;

export type MessageSubmitSseVariables = {
  body: Schemas.MessageSubmitRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchMessageSubmitSse = (
  variables: MessageSubmitSseVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    MessageSubmitSseError,
    Schemas.MessageSubmitRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/messages/submitstream",
    method: "post",
    ...variables,
    signal,
  });

export const useMessageSubmitSse = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      MessageSubmitSseError,
      MessageSubmitSseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    MessageSubmitSseError,
    MessageSubmitSseVariables
  >({
    mutationFn: (variables: MessageSubmitSseVariables) =>
      fetchMessageSubmitSse(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AvailableModelsError = Fetcher.ErrorWrapper<undefined>;

export type AvailableModelsResponse = Schemas.ChatModel[];

export type AvailableModelsVariables = V1betaApiContext["fetcherOptions"];

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export const fetchAvailableModels = (
  variables: AvailableModelsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    AvailableModelsResponse,
    AvailableModelsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1beta/me/models", method: "get", ...variables, signal });

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export function availableModelsQuery(variables: AvailableModelsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AvailableModelsResponse>;
};

export function availableModelsQuery(
  variables: AvailableModelsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AvailableModelsResponse>)
    | reactQuery.SkipToken;
};

export function availableModelsQuery(
  variables: AvailableModelsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/models",
      operationId: "availableModels",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAvailableModels(variables, signal),
  };
}

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export const useSuspenseAvailableModels = <TData = AvailableModelsResponse,>(
  variables: AvailableModelsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AvailableModelsResponse,
      AvailableModelsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    AvailableModelsResponse,
    AvailableModelsError,
    TData
  >({
    ...availableModelsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This endpoint returns all available chat models (providers) that the user can use.
 * Each model includes the provider ID and display name.
 */
export const useAvailableModels = <TData = AvailableModelsResponse,>(
  variables: AvailableModelsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AvailableModelsResponse,
      AvailableModelsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    AvailableModelsResponse,
    AvailableModelsError,
    TData
  >({
    ...availableModelsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListOrganizationGroupsQueryParams = {
  /**
   * Filter to only show groups the requesting user is "involved" with.
   * When true, only returns groups that the requesting user is a member of.
   */
  is_involved?: boolean;
  /**
   * Optional search query to filter groups by displayName.
   * Uses Microsoft Graph $search parameter with fuzzy, tokenized matching.
   * When provided (even if empty), only the first page of results is returned for performance.
   * This optimizes search field implementations where typing starts with an empty query.
   */
  query?: string;
};

export type ListOrganizationGroupsError = Fetcher.ErrorWrapper<undefined>;

export type ListOrganizationGroupsVariables = {
  queryParams?: ListOrganizationGroupsQueryParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches groups from the MS Graph API.
 * When is_involved=true, only returns groups the user is a member of.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export const fetchListOrganizationGroups = (
  variables: ListOrganizationGroupsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.OrganizationGroupsResponse,
    ListOrganizationGroupsError,
    undefined,
    {},
    ListOrganizationGroupsQueryParams,
    {}
  >({
    url: "/api/v1beta/me/organization/groups",
    method: "get",
    ...variables,
    signal,
  });

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches groups from the MS Graph API.
 * When is_involved=true, only returns groups the user is a member of.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export function listOrganizationGroupsQuery(
  variables: ListOrganizationGroupsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.OrganizationGroupsResponse>;
};

export function listOrganizationGroupsQuery(
  variables: ListOrganizationGroupsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.OrganizationGroupsResponse>)
    | reactQuery.SkipToken;
};

export function listOrganizationGroupsQuery(
  variables: ListOrganizationGroupsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/organization/groups",
      operationId: "listOrganizationGroups",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchListOrganizationGroups(variables, signal),
  };
}

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches groups from the MS Graph API.
 * When is_involved=true, only returns groups the user is a member of.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export const useSuspenseListOrganizationGroups = <
  TData = Schemas.OrganizationGroupsResponse,
>(
  variables: ListOrganizationGroupsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrganizationGroupsResponse,
      ListOrganizationGroupsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.OrganizationGroupsResponse,
    ListOrganizationGroupsError,
    TData
  >({
    ...listOrganizationGroupsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches groups from the MS Graph API.
 * When is_involved=true, only returns groups the user is a member of.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export const useListOrganizationGroups = <
  TData = Schemas.OrganizationGroupsResponse,
>(
  variables: ListOrganizationGroupsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrganizationGroupsResponse,
      ListOrganizationGroupsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.OrganizationGroupsResponse,
    ListOrganizationGroupsError,
    TData
  >({
    ...listOrganizationGroupsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListOrganizationUsersQueryParams = {
  /**
   * Filter to only show users the requesting user is "involved" with.
   * When true, only returns users who share at least one group with the requesting user.
   */
  is_involved?: boolean;
  /**
   * Optional search query to filter users by displayName.
   * Uses Microsoft Graph $search parameter with fuzzy, tokenized matching.
   * When provided (even if empty), only the first page of results is returned for performance.
   * This optimizes search field implementations where typing starts with an empty query.
   */
  query?: string;
};

export type ListOrganizationUsersError = Fetcher.ErrorWrapper<undefined>;

export type ListOrganizationUsersVariables = {
  queryParams?: ListOrganizationUsersQueryParams;
} & V1betaApiContext["fetcherOptions"];

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches users from the MS Graph API.
 * When is_involved=true, only returns users who share at least one group with the requesting user.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export const fetchListOrganizationUsers = (
  variables: ListOrganizationUsersVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.OrganizationUsersResponse,
    ListOrganizationUsersError,
    undefined,
    {},
    ListOrganizationUsersQueryParams,
    {}
  >({
    url: "/api/v1beta/me/organization/users",
    method: "get",
    ...variables,
    signal,
  });

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches users from the MS Graph API.
 * When is_involved=true, only returns users who share at least one group with the requesting user.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export function listOrganizationUsersQuery(
  variables: ListOrganizationUsersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.OrganizationUsersResponse>;
};

export function listOrganizationUsersQuery(
  variables: ListOrganizationUsersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.OrganizationUsersResponse>)
    | reactQuery.SkipToken;
};

export function listOrganizationUsersQuery(
  variables: ListOrganizationUsersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/organization/users",
      operationId: "listOrganizationUsers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchListOrganizationUsers(variables, signal),
  };
}

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches users from the MS Graph API.
 * When is_involved=true, only returns users who share at least one group with the requesting user.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export const useSuspenseListOrganizationUsers = <
  TData = Schemas.OrganizationUsersResponse,
>(
  variables: ListOrganizationUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrganizationUsersResponse,
      ListOrganizationUsersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.OrganizationUsersResponse,
    ListOrganizationUsersError,
    TData
  >({
    ...listOrganizationUsersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * If the Entra ID integration is not enabled, returns an empty list.
 * If enabled, fetches users from the MS Graph API.
 * When is_involved=true, only returns users who share at least one group with the requesting user.
 * When query parameter is provided (even if empty), returns only the first page for performance.
 * Non-empty queries use $search for fuzzy matching.
 */
export const useListOrganizationUsers = <
  TData = Schemas.OrganizationUsersResponse,
>(
  variables: ListOrganizationUsersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrganizationUsersResponse,
      ListOrganizationUsersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.OrganizationUsersResponse,
    ListOrganizationUsersError,
    TData
  >({
    ...listOrganizationUsersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ProfileError = Fetcher.ErrorWrapper<undefined>;

export type ProfileVariables = V1betaApiContext["fetcherOptions"];

export const fetchProfile = (
  variables: ProfileVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<Schemas.UserProfile, ProfileError, undefined, {}, {}, {}>({
    url: "/api/v1beta/me/profile",
    method: "get",
    ...variables,
    signal,
  });

export function profileQuery(variables: ProfileVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserProfile>;
};

export function profileQuery(
  variables: ProfileVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UserProfile>)
    | reactQuery.SkipToken;
};

export function profileQuery(
  variables: ProfileVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/profile",
      operationId: "profile",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchProfile(variables, signal),
  };
}

export const useSuspenseProfile = <TData = Schemas.UserProfile,>(
  variables: ProfileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, ProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<Schemas.UserProfile, ProfileError, TData>({
    ...profileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useProfile = <TData = Schemas.UserProfile,>(
  variables: ProfileVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, ProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<Schemas.UserProfile, ProfileError, TData>({
    ...profileQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateProfilePreferencesError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProfilePreferencesVariables = {
  body?: Schemas.UpdateProfilePreferencesRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchUpdateProfilePreferences = (
  variables: UpdateProfilePreferencesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.UserProfile,
    UpdateProfilePreferencesError,
    Schemas.UpdateProfilePreferencesRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/me/profile/preferences",
    method: "put",
    ...variables,
    signal,
  });

export const useUpdateProfilePreferences = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserProfile,
      UpdateProfilePreferencesError,
      UpdateProfilePreferencesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.UserProfile,
    UpdateProfilePreferencesError,
    UpdateProfilePreferencesVariables
  >({
    mutationFn: (variables: UpdateProfilePreferencesVariables) =>
      fetchUpdateProfilePreferences(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RecentChatsQueryParams = {
  /**
   * Maximum number of chats to return per page. Defaults to 30 if not provided. Larger values may impact performance.
   *
   * @format int64
   * @minimum 0
   */
  limit?: number;
  /**
   * Number of chats to skip for pagination. Defaults to 0 if not provided.
   *
   * @format int64
   * @minimum 0
   */
  offset?: number;
  /**
   * Whether to include archived chats in results. Defaults to false if not provided.
   */
  include_archived?: boolean;
};

export type RecentChatsError = Fetcher.ErrorWrapper<undefined>;

export type RecentChatsVariables = {
  queryParams?: RecentChatsQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchRecentChats = (
  variables: RecentChatsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.RecentChatsResponse,
    RecentChatsError,
    undefined,
    {},
    RecentChatsQueryParams,
    {}
  >({
    url: "/api/v1beta/me/recent_chats",
    method: "get",
    ...variables,
    signal,
  });

export function recentChatsQuery(variables: RecentChatsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RecentChatsResponse>;
};

export function recentChatsQuery(
  variables: RecentChatsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RecentChatsResponse>)
    | reactQuery.SkipToken;
};

export function recentChatsQuery(
  variables: RecentChatsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/me/recent_chats",
      operationId: "recentChats",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchRecentChats(variables, signal),
  };
}

export const useSuspenseRecentChats = <TData = Schemas.RecentChatsResponse,>(
  variables: RecentChatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RecentChatsResponse,
      RecentChatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RecentChatsResponse,
    RecentChatsError,
    TData
  >({
    ...recentChatsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecentChats = <TData = Schemas.RecentChatsResponse,>(
  variables: RecentChatsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RecentChatsResponse,
      RecentChatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.RecentChatsResponse,
    RecentChatsError,
    TData
  >({
    ...recentChatsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MessagesError = Fetcher.ErrorWrapper<undefined>;

export type MessagesResponse = Schemas.Message[];

export type MessagesVariables = V1betaApiContext["fetcherOptions"];

export const fetchMessages = (
  variables: MessagesVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<MessagesResponse, MessagesError, undefined, {}, {}, {}>({
    url: "/api/v1beta/messages",
    method: "get",
    ...variables,
    signal,
  });

export function messagesQuery(variables: MessagesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MessagesResponse>;
};

export function messagesQuery(
  variables: MessagesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MessagesResponse>)
    | reactQuery.SkipToken;
};

export function messagesQuery(
  variables: MessagesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/messages",
      operationId: "messages",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchMessages(variables, signal),
  };
}

export const useSuspenseMessages = <TData = MessagesResponse,>(
  variables: MessagesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<MessagesResponse, MessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<MessagesResponse, MessagesError, TData>({
    ...messagesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMessages = <TData = MessagesResponse,>(
  variables: MessagesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<MessagesResponse, MessagesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<MessagesResponse, MessagesError, TData>({
    ...messagesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SubmitMessageFeedbackPathParams = {
  /**
   * The ID of the message to submit feedback for
   */
  messageId: string;
};

export type SubmitMessageFeedbackError = Fetcher.ErrorWrapper<undefined>;

export type SubmitMessageFeedbackVariables = {
  body: Schemas.MessageFeedbackRequest;
  pathParams: SubmitMessageFeedbackPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchSubmitMessageFeedback = (
  variables: SubmitMessageFeedbackVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.MessageFeedback,
    SubmitMessageFeedbackError,
    Schemas.MessageFeedbackRequest,
    {},
    {},
    SubmitMessageFeedbackPathParams
  >({
    url: "/api/v1beta/messages/{messageId}/feedback",
    method: "put",
    ...variables,
    signal,
  });

export const useSubmitMessageFeedback = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MessageFeedback,
      SubmitMessageFeedbackError,
      SubmitMessageFeedbackVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.MessageFeedback,
    SubmitMessageFeedbackError,
    SubmitMessageFeedbackVariables
  >({
    mutationFn: (variables: SubmitMessageFeedbackVariables) =>
      fetchSubmitMessageFeedback(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PromptOptimizerError = Fetcher.ErrorWrapper<undefined>;

export type PromptOptimizerVariables = {
  body: Schemas.PromptOptimizerRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchPromptOptimizer = (
  variables: PromptOptimizerVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.PromptOptimizerResponse,
    PromptOptimizerError,
    Schemas.PromptOptimizerRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/prompt-optimizer",
    method: "post",
    ...variables,
    signal,
  });

export const usePromptOptimizer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PromptOptimizerResponse,
      PromptOptimizerError,
      PromptOptimizerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.PromptOptimizerResponse,
    PromptOptimizerError,
    PromptOptimizerVariables
  >({
    mutationFn: (variables: PromptOptimizerVariables) =>
      fetchPromptOptimizer(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ListShareGrantsQueryParams = {
  /**
   * The type of resource (e.g., 'assistant')
   */
  resource_type: string;
  /**
   * The ID of the resource
   */
  resource_id: string;
};

export type ListShareGrantsError = Fetcher.ErrorWrapper<undefined>;

export type ListShareGrantsVariables = {
  queryParams: ListShareGrantsQueryParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchListShareGrants = (
  variables: ListShareGrantsVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.ListShareGrantsResponse,
    ListShareGrantsError,
    undefined,
    {},
    ListShareGrantsQueryParams,
    {}
  >({ url: "/api/v1beta/share-grants", method: "get", ...variables, signal });

export function listShareGrantsQuery(variables: ListShareGrantsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.ListShareGrantsResponse>;
};

export function listShareGrantsQuery(
  variables: ListShareGrantsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ListShareGrantsResponse>)
    | reactQuery.SkipToken;
};

export function listShareGrantsQuery(
  variables: ListShareGrantsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/v1beta/share-grants",
      operationId: "listShareGrants",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchListShareGrants(variables, signal),
  };
}

export const useSuspenseListShareGrants = <
  TData = Schemas.ListShareGrantsResponse,
>(
  variables: ListShareGrantsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListShareGrantsResponse,
      ListShareGrantsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ListShareGrantsResponse,
    ListShareGrantsError,
    TData
  >({
    ...listShareGrantsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useListShareGrants = <TData = Schemas.ListShareGrantsResponse,>(
  variables: ListShareGrantsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListShareGrantsResponse,
      ListShareGrantsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<
    Schemas.ListShareGrantsResponse,
    ListShareGrantsError,
    TData
  >({
    ...listShareGrantsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CreateShareGrantError = Fetcher.ErrorWrapper<undefined>;

export type CreateShareGrantVariables = {
  body: Schemas.CreateShareGrantRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchCreateShareGrant = (
  variables: CreateShareGrantVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.CreateShareGrantResponse,
    CreateShareGrantError,
    Schemas.CreateShareGrantRequest,
    {},
    {},
    {}
  >({ url: "/api/v1beta/share-grants", method: "post", ...variables, signal });

export const useCreateShareGrant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreateShareGrantResponse,
      CreateShareGrantError,
      CreateShareGrantVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.CreateShareGrantResponse,
    CreateShareGrantError,
    CreateShareGrantVariables
  >({
    mutationFn: (variables: CreateShareGrantVariables) =>
      fetchCreateShareGrant(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteShareGrantPathParams = {
  /**
   * The ID of the share grant to delete
   */
  grantId: string;
};

export type DeleteShareGrantError = Fetcher.ErrorWrapper<undefined>;

export type DeleteShareGrantVariables = {
  pathParams: DeleteShareGrantPathParams;
} & V1betaApiContext["fetcherOptions"];

export const fetchDeleteShareGrant = (
  variables: DeleteShareGrantVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    undefined,
    DeleteShareGrantError,
    undefined,
    {},
    {},
    DeleteShareGrantPathParams
  >({
    url: "/api/v1beta/share-grants/{grantId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteShareGrant = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteShareGrantError,
      DeleteShareGrantVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    undefined,
    DeleteShareGrantError,
    DeleteShareGrantVariables
  >({
    mutationFn: (variables: DeleteShareGrantVariables) =>
      fetchDeleteShareGrant(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type TokenUsageEstimateError = Fetcher.ErrorWrapper<undefined>;

export type TokenUsageEstimateVariables = {
  body?: Schemas.TokenUsageRequest;
} & V1betaApiContext["fetcherOptions"];

export const fetchTokenUsageEstimate = (
  variables: TokenUsageEstimateVariables,
  signal?: AbortSignal,
) =>
  v1betaApiFetch<
    Schemas.TokenUsageResponse,
    TokenUsageEstimateError,
    Schemas.TokenUsageRequest,
    {},
    {},
    {}
  >({
    url: "/api/v1beta/token_usage/estimate",
    method: "post",
    ...variables,
    signal,
  });

export const useTokenUsageEstimate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenUsageResponse,
      TokenUsageEstimateError,
      TokenUsageEstimateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useV1betaApiContext();
  return reactQuery.useMutation<
    Schemas.TokenUsageResponse,
    TokenUsageEstimateError,
    TokenUsageEstimateVariables
  >({
    mutationFn: (variables: TokenUsageEstimateVariables) =>
      fetchTokenUsageEstimate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HealthError = Fetcher.ErrorWrapper<undefined>;

export type HealthVariables = V1betaApiContext["fetcherOptions"];

export const fetchHealth = (variables: HealthVariables, signal?: AbortSignal) =>
  v1betaApiFetch<undefined, HealthError, undefined, {}, {}, {}>({
    url: "/health",
    method: "get",
    ...variables,
    signal,
  });

export function healthQuery(variables: HealthVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function healthQuery(
  variables: HealthVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function healthQuery(variables: HealthVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/health",
      operationId: "health",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchHealth(variables, signal),
  };
}

export const useSuspenseHealth = <TData = undefined,>(
  variables: HealthVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, HealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useSuspenseQuery<undefined, HealthError, TData>({
    ...healthQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useHealth = <TData = undefined,>(
  variables: HealthVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, HealthError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useV1betaApiContext(options);
  return reactQuery.useQuery<undefined, HealthError, TData>({
    ...healthQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/v1beta/assistants";
      operationId: "listAssistants";
      variables: ListAssistantsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/assistants/{assistantId}";
      operationId: "getAssistant";
      variables: GetAssistantVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/chats";
      operationId: "chats";
      variables: ChatsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/chats/{chatId}/messages";
      operationId: "chatMessages";
      variables: ChatMessagesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/files/{fileId}";
      operationId: "getFile";
      variables: GetFileVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/integrations/sharepoint/all-drives";
      operationId: "allDrives";
      variables: AllDrivesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/integrations/sharepoint/drives/{driveId}";
      operationId: "getDriveRoot";
      variables: GetDriveRootVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/integrations/sharepoint/drives/{driveId}/items/{itemId}";
      operationId: "getDriveItem";
      variables: GetDriveItemVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/integrations/sharepoint/drives/{driveId}/items/{itemId}/children";
      operationId: "getDriveItemChildren";
      variables: GetDriveItemChildrenVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/budget";
      operationId: "budgetStatus";
      variables: BudgetStatusVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/facets";
      operationId: "facets";
      variables: FacetsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/file-capabilities";
      operationId: "fileCapabilities";
      variables: FileCapabilitiesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/frequent_assistants";
      operationId: "frequentAssistants";
      variables: FrequentAssistantsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/models";
      operationId: "availableModels";
      variables: AvailableModelsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/organization/groups";
      operationId: "listOrganizationGroups";
      variables: ListOrganizationGroupsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/organization/users";
      operationId: "listOrganizationUsers";
      variables: ListOrganizationUsersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/profile";
      operationId: "profile";
      variables: ProfileVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/me/recent_chats";
      operationId: "recentChats";
      variables: RecentChatsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/messages";
      operationId: "messages";
      variables: MessagesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/v1beta/share-grants";
      operationId: "listShareGrants";
      variables: ListShareGrantsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/health";
      operationId: "health";
      variables: HealthVariables | reactQuery.SkipToken;
    };

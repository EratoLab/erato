/**
 * Generated by @openapi-codegen
 *
 * @version
 */
/**
 * @deprecated true
 */
export type Chat = {
  id: string;
};

/**
 * A message in a chat
 */
export type ChatMessage = {
  /**
   * The ID of the chat this message belongs to
   */
  chat_id: string;
  /**
   * When the message was created
   *
   * @format date-time
   */
  created_at: string;
  /**
   * The text content of the message
   */
  full_text: string;
  /**
   * The unique ID of the message
   */
  id: string;
  /**
   * The IDs of the files that were used to generate this message
   */
  input_files_ids: string[];
  /**
   * Whether this message is in the active thread
   */
  is_message_in_active_thread: boolean;
  /**
   * The ID of the previous message in the thread, if any
   */
  previous_message_id?: null | undefined;
  /**
   * Role of the message sender. May be on of "user", "assistant", "system"
   */
  role: string;
  /**
   * The unique ID of the sibling message, if any
   */
  sibling_message_id?: null | undefined;
  /**
   * When the message was last updated
   *
   * @format date-time
   */
  updated_at: string;
};

/**
 * Statistics for a list of chat messages
 */
export type ChatMessageStats = {
  /**
   * Current offset in the list
   *
   * @format int64
   * @minimum 0
   */
  current_offset: number;
  /**
   * Whether there are more messages available
   */
  has_more: boolean;
  /**
   * Number of messages in the current response
   *
   * @minimum 0
   */
  returned_count: number;
  /**
   * Total number of messages in the chat
   *
   * @format int64
   */
  total_count: number;
};

/**
 * Response for the chat_messages endpoint
 */
export type ChatMessagesResponse = {
  /**
   * The list of messages
   */
  messages: ChatMessage[];
  /**
   * Statistics about the message list
   */
  stats: ChatMessageStats;
};

/**
 * Request to create a new chat without an initial message
 */
export type CreateChatRequest = Record<string, any>;

/**
 * Response for create_chat endpoint
 */
export type CreateChatResponse = {
  /**
   * The ID of the newly created chat
   */
  chat_id: string;
};

export type EditMessageRequest = {
  /**
   * The ID of the message that should be edited with a new response. It will be considered a sibling message to the new message.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  message_id: string;
  /**
   * The IDs of any files that should replace the input files. These files must already be uploaded to the file_uploads table.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  replace_input_files_ids?: string[];
  /**
   * The text of the message that should replace the user message.
   *
   * @example Hello, world!
   */
  replace_user_message: string;
};

export type EditMessageStreamingResponseMessage =
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "message_complete";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    })
  | (MessageSubmitStreamingResponseUserMessageSaved & {
      message_type: "user_message_saved";
    });

/**
 * Response for file upload
 */
export type FileUploadItem = {
  /**
   * Pre-signed URL for downloading the file directly from storage
   */
  download_url: string;
  /**
   * The original filename of the uploaded file
   */
  filename: string;
  /**
   * The unique ID of the uploaded file
   */
  id: string;
};

/**
 * Response for file upload
 */
export type FileUploadResponse = {
  /**
   * The list of uploaded files with their IDs and filenames
   */
  files: FileUploadItem[];
};

export type Message = {
  id: string;
};

export type MessageSubmitRequest = {
  /**
   * The ID of an existing chat to use. If provided, the chat with this ID will be used instead of creating a new one.
   * This is useful for scenarios where you have created a chat first (e.g. for file uploads) before sending the first message.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  existing_chat_id?: null | undefined;
  /**
   * The IDs of any files attached to this message. These files must already be uploaded to the file_uploads table.
   * The files should normally only be provided with the first message they appear in the chat. After that they can assumed to be part of the chat history.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  input_files_ids?: string[];
  /**
   * The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  previous_message_id?: null | undefined;
  /**
   * The text of the message.
   *
   * @example Hello, world!
   */
  user_message: string;
};

export type MessageSubmitStreamingResponseChatCreated = {
  /**
   * @format uuid
   */
  chat_id: string;
};

export type MessageSubmitStreamingResponseMessage =
  | (MessageSubmitStreamingResponseChatCreated & {
      message_type: "chat_created";
    })
  | (MessageSubmitStreamingResponseUserMessageSaved & {
      message_type: "user_message_saved";
    })
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "message_complete";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    });

export type MessageSubmitStreamingResponseMessageComplete = {
  full_text: string;
  message: ChatMessage;
  /**
   * @format uuid
   */
  message_id: string;
};

export type MessageSubmitStreamingResponseMessageTextDelta = {
  new_text: string;
};

export type MessageSubmitStreamingResponseUserMessageSaved = {
  message: ChatMessage;
  /**
   * @format uuid
   */
  message_id: string;
};

export type MultipartFormFile = {
  /**
   * @format binary
   */
  file: Blob;
  name: string;
};

export type RecentChat = {
  /**
   * Files uploaded to this chat
   */
  file_uploads: FileUploadItem[];
  id: string;
  /**
   * Time of the last message in the chat.
   *
   * @format date-time
   */
  last_message_at: string;
  /**
   * Title of the chat, as generated by a summary of the chat.
   */
  title_by_summary: string;
};

/**
 * Statistics for a list of recent chats
 */
export type RecentChatStats = {
  /**
   * Current offset in the list
   *
   * @format int64
   * @minimum 0
   */
  current_offset: number;
  /**
   * Whether there are more chats available
   */
  has_more: boolean;
  /**
   * Number of chats in the current response
   *
   * @minimum 0
   */
  returned_count: number;
  /**
   * Total number of chats available
   *
   * @format int64
   */
  total_count: number;
};

/**
 * Response for the recent_chats endpoint
 */
export type RecentChatsResponse = {
  /**
   * The list of recent chats
   */
  chats: RecentChat[];
  /**
   * Statistics about the chat list
   */
  stats: RecentChatStats;
};

export type RegenerateMessageRequest = {
  /**
   * The ID of the message that should have a replacement response generated.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  current_message_id: string;
};

export type RegenerateMessageStreamingResponseMessage =
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "message_complete";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    });

export type UserProfile = {
  /**
   * The user's email address. Shouldn't be used as a unique identifier, as it may change.
   */
  email?: null | undefined;
  id: string;
  /**
   * The user's display name.
   */
  name?: null | undefined;
  /**
   * The user's profile picture URL.
   */
  picture?: null | undefined;
  /**
   * The user's preferred language.
   *
   * The final determined language is intersected with our supported languages, to determine the final language.
   *
   * Will be a BCP 47 language tag (e.g. "en" or "en-US").
   *
   * This is derived in the following order (highest priority first):
   * - ID token claims
   * - Browser Accept-Language header
   * - Default to "en"
   */
  preferred_language: string;
};

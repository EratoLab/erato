/**
 * Generated by @openapi-codegen
 *
 * @version
 */
/**
 * Request to archive a chat
 */
export type ArchiveChatRequest = Record<string, any>;

/**
 * Response from the archive chat endpoint
 */
export type ArchiveChatResponse = {
  /**
   * The time when the chat was archived
   *
   * @format date-time
   */
  archived_at: string;
  /**
   * The ID of the archived chat
   */
  chat_id: string;
};

/**
 * @deprecated true
 */
export type Chat = {
  id: string;
};

/**
 * A message in a chat
 */
export type ChatMessage = {
  /**
   * The ID of the chat this message belongs to
   */
  chat_id: string;
  /**
   * The text content of the message
   */
  content: ContentPart[];
  /**
   * When the message was created
   *
   * @format date-time
   */
  created_at: string;
  /**
   * The unique ID of the message
   */
  id: string;
  /**
   * The IDs of the files that were used to generate this message
   */
  input_files_ids: string[];
  /**
   * Whether this message is in the active thread
   */
  is_message_in_active_thread: boolean;
  /**
   * The ID of the previous message in the thread, if any
   */
  previous_message_id?: null | undefined;
  /**
   * Role of the message sender. May be on of "user", "assistant", "system"
   */
  role: string;
  /**
   * The unique ID of the sibling message, if any
   */
  sibling_message_id?: null | undefined;
  /**
   * When the message was last updated
   *
   * @format date-time
   */
  updated_at: string;
};

/**
 * Statistics for a list of chat messages
 */
export type ChatMessageStats = {
  /**
   * Current offset in the list
   *
   * @format int64
   * @minimum 0
   */
  current_offset: number;
  /**
   * Whether there are more messages available
   */
  has_more: boolean;
  /**
   * Number of messages in the current response
   *
   * @minimum 0
   */
  returned_count: number;
  /**
   * Total number of messages in the chat
   *
   * @format int64
   */
  total_count: number;
};

/**
 * Response for the chat_messages endpoint
 */
export type ChatMessagesResponse = {
  /**
   * The list of messages
   */
  messages: ChatMessage[];
  /**
   * Statistics about the message list
   */
  stats: ChatMessageStats;
};

/**
 * A chat model available to the user
 */
export type ChatModel = {
  /**
   * The unique ID of the chat provider
   */
  chat_provider_id: string;
  /**
   * The display name of the model shown to users
   */
  model_display_name: string;
};

export type ContentPart =
  | (ContentPartText & {
      content_type: "text";
    })
  | (ToolUse & {
      content_type: "tool_use";
    });

export type ContentPartText = {
  text: string;
};

/**
 * Request to create a new chat without an initial message
 */
export type CreateChatRequest = Record<string, any>;

/**
 * Response for create_chat endpoint
 */
export type CreateChatResponse = {
  /**
   * The ID of the newly created chat
   */
  chat_id: string;
};

export type EditMessageRequest = {
  /**
   * The ID of the chat provider to use for generation. If not provided, will use the highest priority model for the user.
   *
   * @example primary
   */
  chat_provider_id?: null | string;
  /**
   * The ID of the message that should be edited with a new response. It will be considered a sibling message to the new message.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  message_id: string;
  /**
   * The IDs of any files that should replace the input files. These files must already be uploaded to the file_uploads table.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  replace_input_files_ids?: string[];
  /**
   * The text of the message that should replace the user message.
   *
   * @example Hello, world!
   */
  replace_user_message: string;
};

export type EditMessageStreamingResponseMessage =
  | (MessageSubmitStreamingResponseAssistantMessageStarted & {
      message_type: "assistant_message_started";
    })
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "assistant_message_completed";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    })
  | (MessageSubmitStreamingResponseToolCallProposed & {
      message_type: "tool_call_proposed";
    })
  | (MessageSubmitStreamingResponseToolCallUpdate & {
      message_type: "tool_call_update";
    })
  | (MessageSubmitStreamingResponseUserMessageSaved & {
      message_type: "user_message_saved";
    });

/**
 * Response for file upload
 */
export type FileUploadItem = {
  /**
   * Pre-signed URL for downloading the file directly from storage
   */
  download_url: string;
  /**
   * The original filename of the uploaded file
   */
  filename: string;
  /**
   * The unique ID of the uploaded file
   */
  id: string;
};

/**
 * Response for file upload
 */
export type FileUploadResponse = {
  /**
   * The list of uploaded files with their IDs and filenames
   */
  files: FileUploadItem[];
};

export type Message = {
  id: string;
};

export type MessageSubmitRequest = {
  /**
   * The ID of the chat provider to use for generation. If not provided, will use the highest priority model for the user.
   *
   * @example primary
   */
  chat_provider_id?: null | string;
  /**
   * The ID of an existing chat to use. If provided, the chat with this ID will be used instead of creating a new one.
   * This is useful for scenarios where you have created a chat first (e.g. for file uploads) before sending the first message.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  existing_chat_id?: null | undefined;
  /**
   * The IDs of any files attached to this message. These files must already be uploaded to the file_uploads table.
   * The files should normally only be provided with the first message they appear in the chat. After that they can assumed to be part of the chat history.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  input_files_ids?: string[];
  /**
   * The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  previous_message_id?: null | undefined;
  /**
   * The text of the message.
   *
   * @example Hello, world!
   */
  user_message: string;
};

export type MessageSubmitStreamingResponseAssistantMessageStarted = {
  /**
   * @format uuid
   */
  message_id: string;
};

export type MessageSubmitStreamingResponseChatCreated = {
  /**
   * @format uuid
   */
  chat_id: string;
};

export type MessageSubmitStreamingResponseMessage =
  | (MessageSubmitStreamingResponseChatCreated & {
      message_type: "chat_created";
    })
  | (MessageSubmitStreamingResponseUserMessageSaved & {
      message_type: "user_message_saved";
    })
  | (MessageSubmitStreamingResponseAssistantMessageStarted & {
      message_type: "assistant_message_started";
    })
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "assistant_message_completed";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    })
  | (MessageSubmitStreamingResponseToolCallProposed & {
      message_type: "tool_call_proposed";
    })
  | (MessageSubmitStreamingResponseToolCallUpdate & {
      message_type: "tool_call_update";
    });

export type MessageSubmitStreamingResponseMessageComplete = {
  content: ContentPart[];
  message: ChatMessage;
  /**
   * @format uuid
   */
  message_id: string;
};

export type MessageSubmitStreamingResponseMessageTextDelta = {
  /**
   * @minimum 0
   */
  content_index: number;
  /**
   * @format uuid
   */
  message_id: string;
  new_text: string;
};

export type MessageSubmitStreamingResponseToolCallProposed = {
  /**
   * @minimum 0
   */
  content_index: number;
  input?: null | Value;
  /**
   * @format uuid
   */
  message_id: string;
  tool_call_id: string;
  tool_name: string;
};

export type MessageSubmitStreamingResponseToolCallUpdate = {
  /**
   * @minimum 0
   */
  content_index: number;
  input?: null | Value;
  /**
   * @format uuid
   */
  message_id: string;
  output?: null | Value;
  progress_message?: null | undefined;
  status: ToolCallStatus;
  tool_call_id: string;
  tool_name: string;
};

export type MessageSubmitStreamingResponseUserMessageSaved = {
  message: ChatMessage;
  /**
   * @format uuid
   */
  message_id: string;
};

export type MultipartFormFile = {
  /**
   * @format binary
   */
  file: Blob;
  name: string;
};

export type RecentChat = {
  /**
   * When this chat was archived by the user.
   *
   * @format date-time
   */
  archived_at?: null | undefined;
  /**
   * Files uploaded to this chat
   */
  file_uploads: FileUploadItem[];
  id: string;
  /**
   * The chat provider ID used for the most recent message
   */
  last_chat_provider_id?: null | string;
  /**
   * Time of the last message in the chat.
   *
   * @format date-time
   */
  last_message_at: string;
  last_model?: null | ChatModel;
  /**
   * Title of the chat, as generated by a summary of the chat.
   */
  title_by_summary: string;
};

/**
 * Statistics for a list of recent chats
 */
export type RecentChatStats = {
  /**
   * Current offset in the list
   *
   * @format int64
   * @minimum 0
   */
  current_offset: number;
  /**
   * Whether there are more chats available
   */
  has_more: boolean;
  /**
   * Number of chats in the current response
   *
   * @minimum 0
   */
  returned_count: number;
  /**
   * Total number of chats available
   *
   * @format int64
   */
  total_count: number;
};

/**
 * Response for the recent_chats endpoint
 */
export type RecentChatsResponse = {
  /**
   * The list of recent chats
   */
  chats: RecentChat[];
  /**
   * Statistics about the chat list
   */
  stats: RecentChatStats;
};

export type RegenerateMessageRequest = {
  /**
   * The ID of the chat provider to use for generation. If not provided, will use the highest priority model for the user.
   *
   * @example primary
   */
  chat_provider_id?: null | string;
  /**
   * The ID of the message that should have a replacement response generated.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  current_message_id: string;
};

export type RegenerateMessageStreamingResponseMessage =
  | (MessageSubmitStreamingResponseAssistantMessageStarted & {
      message_type: "assistant_message_started";
    })
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "assistant_message_completed";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    })
  | (MessageSubmitStreamingResponseToolCallProposed & {
      message_type: "tool_call_proposed";
    })
  | (MessageSubmitStreamingResponseToolCallUpdate & {
      message_type: "tool_call_update";
    });

export type TokenUsageRequest = {
  /**
   * The ID of an existing chat to use. If provided, the chat with this ID will be used instead of creating a new one.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  existing_chat_id?: null | undefined;
  /**
   * The IDs of any files attached to this message. These files must already be uploaded to the file_uploads table.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  input_files_ids?: string[];
  /**
   * The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  previous_message_id?: null | undefined;
  /**
   * The text of the message.
   *
   * @example Hello, world!
   */
  user_message: string;
};

/**
 * Response for the token_usage_estimate endpoint
 */
export type TokenUsageResponse = {
  /**
   * Detailed token usage for each file
   */
  file_details: TokenUsageResponseFileItem[];
  /**
   * Overall statistics about token usage
   */
  stats: TokenUsageStats;
};

/**
 * Token usage details for an individual file
 */
export type TokenUsageResponseFileItem = {
  /**
   * The original filename of the file
   */
  filename: string;
  /**
   * The unique ID of the file
   */
  id: string;
  /**
   * Number of tokens used for this file's content
   *
   * @minimum 0
   */
  token_count: number;
};

/**
 * Token usage statistics for the request
 */
export type TokenUsageStats = {
  /**
   * Number of tokens in file contents
   *
   * @minimum 0
   */
  file_tokens: number;
  /**
   * Number of tokens in previous messages (chat history)
   *
   * @minimum 0
   */
  history_tokens: number;
  /**
   * The configured model's maximum token limit
   *
   * @format int32
   * @minimum 0
   */
  max_tokens: number;
  /**
   * Remaining tokens available for the model response
   *
   * @format int32
   * @minimum 0
   */
  remaining_tokens: number;
  /**
   * Total number of tokens in the request
   *
   * @minimum 0
   */
  total_tokens: number;
  /**
   * Number of tokens in the user message
   *
   * @minimum 0
   */
  user_message_tokens: number;
};

export type ToolCallStatus = "in_progress" | "success" | "error";

export type ToolUse = {
  input?: null | Value;
  output?: null | Value;
  progress_message?: string;
  status: ToolCallStatus;
  tool_call_id: string;
  tool_name: string;
};

export type UserProfile = {
  /**
   * The user's email address. Shouldn't be used as a unique identifier, as it may change.
   */
  email?: null | undefined;
  id: string;
  /**
   * The user's display name.
   */
  name?: null | undefined;
  /**
   * The user's profile picture URL.
   */
  picture?: null | undefined;
  /**
   * The user's preferred language.
   *
   * The final determined language is intersected with our supported languages, to determine the final language.
   *
   * Will be a BCP 47 language tag (e.g. "en" or "en-US").
   *
   * This is derived in the following order (highest priority first):
   * - ID token claims
   * - Browser Accept-Language header
   * - Default to "en"
   */
  preferred_language: string;
};

export type Value = void;

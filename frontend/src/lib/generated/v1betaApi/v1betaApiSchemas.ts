/**
 * Generated by @openapi-codegen
 *
 * @version
 */
/**
 * Response for the all-drives endpoint
 */
export type AllDrivesResponse = {
  /**
   * List of drives accessible to the user
   */
  drives: Drive[];
};

/**
 * Request to archive an assistant
 */
export type ArchiveAssistantRequest = Record<string, any>;

/**
 * Response when archiving an assistant
 */
export type ArchiveAssistantResponse = {
  /**
   * When the assistant was archived
   *
   * @format date-time
   */
  archived_at: string;
  /**
   * The ID of the archived assistant
   */
  id: string;
};

/**
 * Request to archive a chat
 */
export type ArchiveChatRequest = Record<string, any>;

/**
 * Response from the archive chat endpoint
 */
export type ArchiveChatResponse = {
  /**
   * The time when the chat was archived
   *
   * @format date-time
   */
  archived_at: string;
  /**
   * The ID of the archived chat
   */
  chat_id: string;
};

/**
 * An assistant model
 */
export type Assistant = {
  /**
   * When this assistant was archived
   *
   * @format date-time
   */
  archived_at?: string;
  /**
   * Whether the current user can edit this assistant
   *
   * NOTE: Currently this is true only for the assistant owner. In the future,
   * this may include collaborators/roles/policy-based permissions.
   */
  can_edit: boolean;
  /**
   * When this assistant was created
   *
   * @format date-time
   */
  created_at: string;
  /**
   * Default chat provider/model ID for this assistant
   */
  default_chat_provider?: string;
  /**
   * Optional description of the assistant
   */
  description?: string;
  /**
   * The unique ID of the assistant
   */
  id: string;
  /**
   * List of MCP server IDs available to this assistant
   */
  mcp_server_ids?: string[];
  /**
   * The display name of the assistant
   */
  name: string;
  /**
   * The system prompt used by the assistant
   */
  prompt: string;
  /**
   * When this assistant was last updated
   *
   * @format date-time
   */
  updated_at: string;
};

/**
 * A file associated with an assistant
 */
export type AssistantFile = {
  /**
   * Pre-signed URL for downloading the file
   */
  download_url: string;
  /**
   * The original filename
   */
  filename: string;
  /**
   * The unique ID of the file
   */
  id: string;
};

/**
 * An assistant model
 */
export type AssistantWithFiles = Assistant & {
  /**
   * Files associated with this assistant
   */
  files: AssistantFile[];
};

export type BudgetCurrency = "EUR" | "USD";

/**
 * Budget status information for the current user
 */
export type BudgetStatusResponse = {
  /**
   * The currency configured for display purposes
   */
  budget_currency?: BudgetCurrency;
  /**
   * The budget limit for the time period (unit-less)
   *
   * @format double
   */
  budget_limit?: number;
  /**
   * Number of days in the current budget period
   *
   * @format int32
   * @minimum 0
   */
  budget_period_days?: number;
  /**
   * Current spending in the budget period for the user (unit-less)
   *
   * @format double
   */
  current_spending?: number;
  /**
   * Whether the budget feature is enabled
   */
  enabled: boolean;
  /**
   * The warning threshold (0.0 to 1.0)
   *
   * @format double
   */
  warn_threshold?: number;
};

/**
 * @deprecated true
 */
export type Chat = {
  id: string;
};

/**
 * A message in a chat
 */
export type ChatMessage = {
  /**
   * The ID of the chat this message belongs to
   */
  chat_id: string;
  /**
   * The text content of the message
   */
  content: ContentPart[];
  /**
   * When the message was created
   *
   * @format date-time
   */
  created_at: string;
  /**
   * The unique ID of the message
   */
  id: string;
  /**
   * The IDs of the files that were used to generate this message
   */
  input_files_ids: string[];
  /**
   * Whether this message is in the active thread
   */
  is_message_in_active_thread: boolean;
  /**
   * The ID of the previous message in the thread, if any
   */
  previous_message_id?: string;
  /**
   * Role of the message sender. May be on of "user", "assistant", "system"
   */
  role: string;
  /**
   * The unique ID of the sibling message, if any
   */
  sibling_message_id?: string;
  /**
   * When the message was last updated
   *
   * @format date-time
   */
  updated_at: string;
};

/**
 * Statistics for a list of chat messages
 */
export type ChatMessageStats = {
  /**
   * Current offset in the list
   *
   * @format int64
   * @minimum 0
   */
  current_offset: number;
  /**
   * Whether there are more messages available
   */
  has_more: boolean;
  /**
   * Number of messages in the current response
   *
   * @minimum 0
   */
  returned_count: number;
  /**
   * Total number of messages in the chat
   *
   * @format int64
   */
  total_count: number;
};

/**
 * Response for the chat_messages endpoint
 */
export type ChatMessagesResponse = {
  /**
   * The list of messages
   */
  messages: ChatMessage[];
  /**
   * Statistics about the message list
   */
  stats: ChatMessageStats;
};

/**
 * A chat model available to the user
 */
export type ChatModel = {
  /**
   * The unique ID of the chat provider
   */
  chat_provider_id: string;
  /**
   * The display name of the model shown to users
   */
  model_display_name: string;
};

export type ContentPart =
  | (ContentPartText & {
      content_type: "text";
    })
  | (ToolUse & {
      content_type: "tool_use";
    })
  | (ContentPartTextFilePointer & {
      content_type: "text_file_pointer";
    })
  | (ContentPartImageFilePointer & {
      content_type: "image_file_pointer";
    })
  | {
      base64_data: string;
      content_type: "image";
    };

export type ContentPartImage = {
  base64_data: string;
  content_type: string;
};

export type ContentPartImageFilePointer = {
  download_url: string;
  /**
   * @format uuid
   */
  file_upload_id: string;
};

export type ContentPartText = {
  text: string;
};

export type ContentPartTextFilePointer = {
  /**
   * @format uuid
   */
  file_upload_id: string;
};

/**
 * Request to create a new assistant
 */
export type CreateAssistantRequest = {
  /**
   * Default chat provider/model ID for this assistant
   */
  default_chat_provider?: null | undefined;
  /**
   * Optional description of the assistant
   */
  description?: null | undefined;
  /**
   * Optional list of file upload IDs to associate with this assistant
   */
  file_ids?: null | undefined;
  /**
   * List of MCP server IDs available to this assistant
   */
  mcp_server_ids?: null | undefined;
  /**
   * The name of the assistant
   */
  name: string;
  /**
   * The system prompt for the assistant
   */
  prompt: string;
  /**
   * Optional list of share grants to create with the assistant
   */
  share_grants?: null | undefined;
};

/**
 * An assistant with its associated files
 */
export type CreateAssistantResponse = AssistantWithFiles;

/**
 * Request to create a new chat without an initial message
 */
export type CreateChatRequest = {
  /**
   * Optional assistant ID to base this chat on
   */
  assistant_id?: null | undefined;
};

/**
 * Response for create_chat endpoint
 */
export type CreateChatResponse = {
  /**
   * The ID of the newly created chat
   */
  chat_id: string;
};

/**
 * Request to create a new share grant
 */
export type CreateShareGrantRequest = {
  /**
   * The ID of the resource to share
   */
  resource_id: string;
  /**
   * The type of resource to share (e.g., "assistant")
   */
  resource_type: string;
  /**
   * The role to grant (e.g., "viewer")
   */
  role: string;
  /**
   * The ID of the subject to grant access to
   */
  subject_id: string;
  /**
   * The type of subject ID (e.g., "id" or "oidc_issuer_and_subject")
   */
  subject_id_type: string;
  /**
   * The type of subject to grant access to (e.g., "user")
   */
  subject_type: string;
};

/**
 * A share grant model
 */
export type CreateShareGrantResponse = ShareGrant;

/**
 * A drive accessible to the user (OneDrive, Sharepoint, etc.)
 */
export type Drive = {
  /**
   * The type of drive (e.g., "personal", "documentLibrary")
   */
  drive_type: string;
  /**
   * The unique ID of the drive
   */
  id: string;
  /**
   * The display name of the drive
   */
  name: string;
  /**
   * The owner of the drive, if available
   */
  owner_name?: string;
};

/**
 * A drive item (file or folder)
 */
export type DriveItem = {
  /**
   * The unique ID of the item
   */
  id: string;
  /**
   * Whether this item is a folder
   */
  is_folder: boolean;
  /**
   * When the item was last modified
   *
   * @format date-time
   */
  last_modified?: string;
  /**
   * The MIME type (for files)
   */
  mime_type?: string;
  /**
   * The name of the item
   */
  name: string;
  /**
   * The size in bytes (for files)
   *
   * @format int64
   */
  size?: number;
  /**
   * The web URL to access this item
   */
  web_url?: string;
};

/**
 * A drive item (file or folder)
 */
export type DriveItemResponse = DriveItem & {
  /**
   * The drive ID this item belongs to
   */
  drive_id: string;
};

/**
 * Response for drive items endpoints
 */
export type DriveItemsResponse = {
  /**
   * List of items in the drive or folder
   */
  items: DriveItem[];
};

export type EditMessageRequest = {
  /**
   * The ID of the chat provider to use for generation. If not provided, will use the highest priority model for the user.
   *
   * @example primary
   */
  chat_provider_id?: null | undefined;
  /**
   * The ID of the message that should be edited with a new response. It will be considered a sibling message to the new message.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  message_id: string;
  /**
   * The IDs of any files that should replace the input files. These files must already be uploaded to the file_uploads table.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  replace_input_files_ids?: string[];
  /**
   * The text of the message that should replace the user message.
   *
   * @example Hello, world!
   */
  replace_user_message: string;
};

export type EditMessageStreamingResponseMessage =
  | (MessageSubmitStreamingResponseAssistantMessageStarted & {
      message_type: "assistant_message_started";
    })
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "assistant_message_completed";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    })
  | (MessageSubmitStreamingResponseToolCallProposed & {
      message_type: "tool_call_proposed";
    })
  | (MessageSubmitStreamingResponseToolCallUpdate & {
      message_type: "tool_call_update";
    })
  | (MessageSubmitStreamingResponseUserMessageSaved & {
      message_type: "user_message_saved";
    });

/**
 * Minimal file reference containing only the file ID
 */
export type FileReference = {
  /**
   * The unique ID of the file
   */
  id: string;
};

/**
 * Response for file upload
 */
export type FileUploadItem = {
  /**
   * Pre-signed URL for downloading the file directly from storage
   */
  download_url: string;
  /**
   * The original filename of the uploaded file
   */
  filename: string;
  /**
   * The unique ID of the uploaded file
   */
  id: string;
};

/**
 * Response for file upload
 */
export type FileUploadResponse = {
  /**
   * The list of uploaded files with their IDs and filenames
   */
  files: FileUploadItem[];
};

/**
 * An assistant with its associated files
 */
export type FrequentAssistantItem = AssistantWithFiles & {
  /**
   * Number of times this assistant was used to create chats
   *
   * @format int64
   */
  usage_count: number;
};

/**
 * Response for the frequent_assistants endpoint
 */
export type FrequentAssistantsResponse = {
  /**
   * The list of frequently used assistants
   */
  assistants: FrequentAssistantItem[];
};

/**
 * Request to link an external file (SharePoint, Google Drive, etc.)
 */
export type LinkFileRequest = {
  /**
   * Optional chat ID to associate the file with. If not provided, creates standalone files.
   */
  chat_id?: null | undefined;
  /**
   * Provider-specific metadata (e.g., drive_id, item_id for SharePoint)
   */
  provider_metadata: SharepointProviderMetadata;
  /**
   * The source/provider type: "sharepoint" (future: "google_drive", etc.)
   */
  source: string;
};

/**
 * Response when listing share grants
 */
export type ListShareGrantsResponse = {
  /**
   * The list of share grants
   */
  grants: ShareGrant[];
};

export type Message = {
  id: string;
};

export type MessageSubmitRequest = {
  /**
   * Optional assistant ID to associate with the chat when creating a new chat.
   * If provided with an existing_chat_id, this field is ignored.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  assistant_id?: null | undefined;
  /**
   * The ID of the chat provider to use for generation. If not provided, will use the highest priority model for the user.
   *
   * @example primary
   */
  chat_provider_id?: null | undefined;
  /**
   * The ID of an existing chat to use. If provided, the chat with this ID will be used instead of creating a new one.
   * This is useful for scenarios where you have created a chat first (e.g. for file uploads) before sending the first message.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  existing_chat_id?: null | undefined;
  /**
   * The IDs of any files attached to this message. These files must already be uploaded to the file_uploads table.
   * The files should normally only be provided with the first message they appear in the chat. After that they can assumed to be part of the chat history.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  input_files_ids?: string[];
  /**
   * The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  previous_message_id?: null | undefined;
  /**
   * The text of the message.
   *
   * @example Hello, world!
   */
  user_message: string;
};

export type MessageSubmitStreamingResponseAssistantMessageStarted = {
  /**
   * @format uuid
   */
  message_id: string;
};

export type MessageSubmitStreamingResponseChatCreated = {
  /**
   * @format uuid
   */
  chat_id: string;
};

export type MessageSubmitStreamingResponseMessage =
  | (MessageSubmitStreamingResponseChatCreated & {
      message_type: "chat_created";
    })
  | (MessageSubmitStreamingResponseUserMessageSaved & {
      message_type: "user_message_saved";
    })
  | (MessageSubmitStreamingResponseAssistantMessageStarted & {
      message_type: "assistant_message_started";
    })
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "assistant_message_completed";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    })
  | (MessageSubmitStreamingResponseToolCallProposed & {
      message_type: "tool_call_proposed";
    })
  | (MessageSubmitStreamingResponseToolCallUpdate & {
      message_type: "tool_call_update";
    });

export type MessageSubmitStreamingResponseMessageComplete = {
  content: ContentPart[];
  message: ChatMessage;
  /**
   * @format uuid
   */
  message_id: string;
};

export type MessageSubmitStreamingResponseMessageTextDelta = {
  /**
   * @minimum 0
   */
  content_index: number;
  /**
   * @format uuid
   */
  message_id: string;
  new_text: string;
};

export type MessageSubmitStreamingResponseToolCallProposed = {
  /**
   * @minimum 0
   */
  content_index: number;
  input?: null | Value;
  /**
   * @format uuid
   */
  message_id: string;
  tool_call_id: string;
  tool_name: string;
};

export type MessageSubmitStreamingResponseToolCallUpdate = {
  /**
   * @minimum 0
   */
  content_index: number;
  input?: null | Value;
  /**
   * @format uuid
   */
  message_id: string;
  output?: null | Value;
  progress_message?: string;
  status: ToolCallStatus;
  tool_call_id: string;
  tool_name: string;
};

export type MessageSubmitStreamingResponseUserMessageSaved = {
  message: ChatMessage;
  /**
   * @format uuid
   */
  message_id: string;
};

export type MultipartFormFile = {
  /**
   * @format binary
   */
  file: Blob;
  name: string;
};

/**
 * An organization group
 */
export type OrganizationGroup = {
  /**
   * The display name of the group
   */
  display_name: string;
  /**
   * The unique ID of the group
   */
  id: string;
  /**
   * The subject type ID to use when creating a share grant (always "organization_group_id")
   */
  subject_type_id: string;
};

/**
 * Response for the organization groups endpoint
 */
export type OrganizationGroupsResponse = {
  /**
   * List of groups in the organization
   */
  groups: OrganizationGroup[];
};

/**
 * An organization user
 */
export type OrganizationUser = {
  /**
   * The display name of the user
   */
  display_name: string;
  /**
   * The unique ID of the user
   */
  id: string;
  /**
   * The subject type ID to use when creating a share grant (always "organization_user_id")
   */
  subject_type_id: string;
};

/**
 * Response for the organization users endpoint
 */
export type OrganizationUsersResponse = {
  /**
   * List of users in the organization
   */
  users: OrganizationUser[];
};

export type RecentChat = {
  /**
   * When this chat was archived by the user.
   *
   * @format date-time
   */
  archived_at?: string;
  /**
   * The assistant ID if this chat is based on an assistant
   */
  assistant_id?: string;
  /**
   * The name of the assistant if this chat is based on an assistant
   */
  assistant_name?: string;
  /**
   * Whether the current user can edit this chat (e.g., edit messages)
   *
   * NOTE: Currently this is true only for the chat owner. In the future,
   * this may include collaborators/roles/policy-based permissions.
   */
  can_edit: boolean;
  /**
   * Files uploaded to this chat
   */
  file_uploads: FileReference[];
  id: string;
  /**
   * The chat provider ID used for the most recent message
   */
  last_chat_provider_id?: string;
  /**
   * Time of the last message in the chat.
   *
   * @format date-time
   */
  last_message_at: string;
  /**
   * The model information for the most recent message, if available
   */
  last_model?: ChatModel;
  /**
   * Title of the chat, as generated by a summary of the chat.
   */
  title_by_summary: string;
};

/**
 * Statistics for a list of recent chats
 */
export type RecentChatStats = {
  /**
   * Current offset in the list
   *
   * @format int64
   * @minimum 0
   */
  current_offset: number;
  /**
   * Whether there are more chats available
   */
  has_more: boolean;
  /**
   * Number of chats in the current response
   *
   * @minimum 0
   */
  returned_count: number;
  /**
   * Total number of chats available
   *
   * @format int64
   */
  total_count: number;
};

/**
 * Response for the recent_chats endpoint
 */
export type RecentChatsResponse = {
  /**
   * The list of recent chats
   */
  chats: RecentChat[];
  /**
   * Statistics about the chat list
   */
  stats: RecentChatStats;
};

export type RegenerateMessageRequest = {
  /**
   * The ID of the chat provider to use for generation. If not provided, will use the highest priority model for the user.
   *
   * @example primary
   */
  chat_provider_id?: null | undefined;
  /**
   * The ID of the message that should have a replacement response generated.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  current_message_id: string;
};

export type RegenerateMessageStreamingResponseMessage =
  | (MessageSubmitStreamingResponseAssistantMessageStarted & {
      message_type: "assistant_message_started";
    })
  | (MessageSubmitStreamingResponseMessageComplete & {
      message_type: "assistant_message_completed";
    })
  | (MessageSubmitStreamingResponseMessageTextDelta & {
      message_type: "text_delta";
    })
  | (MessageSubmitStreamingResponseToolCallProposed & {
      message_type: "tool_call_proposed";
    })
  | (MessageSubmitStreamingResponseToolCallUpdate & {
      message_type: "tool_call_update";
    });

export type ResumeStreamRequest = {
  /**
   * The ID of the chat to resume streaming for.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  chat_id: string;
};

/**
 * A share grant model
 */
export type ShareGrant = {
  /**
   * When this share grant was created
   *
   * @format date-time
   */
  created_at: string;
  /**
   * The unique ID of the share grant
   */
  id: string;
  /**
   * The ID of the resource being shared
   */
  resource_id: string;
  /**
   * The type of resource being shared (e.g., "assistant")
   */
  resource_type: string;
  /**
   * The role being granted (e.g., "viewer")
   */
  role: string;
  /**
   * The ID of the subject being granted access
   */
  subject_id: string;
  /**
   * The type of subject ID (e.g., "id" or "oidc_issuer_and_subject")
   */
  subject_id_type: string;
  /**
   * The type of subject being granted access (e.g., "user")
   */
  subject_type: string;
  /**
   * When this share grant was last updated
   *
   * @format date-time
   */
  updated_at: string;
};

/**
 * A share grant to create with the assistant
 */
export type ShareGrantInput = {
  /**
   * The role to grant (e.g., "viewer")
   */
  role: string;
  /**
   * The ID of the subject to grant access to
   */
  subject_id: string;
  /**
   * The type of subject ID (e.g., "id" or "oidc_issuer_and_subject")
   */
  subject_id_type: string;
  /**
   * The type of subject to grant access to (e.g., "user")
   */
  subject_type: string;
};

/**
 * SharePoint-specific metadata for linking files
 */
export type SharepointProviderMetadata = {
  /**
   * The ID of the drive containing the file
   */
  drive_id: string;
  /**
   * The ID of the file item
   */
  item_id: string;
};

export type TokenUsageRequest = {
  /**
   * Optional chat provider ID to use for token estimation. If not provided, uses the default provider.
   *
   * @example gpt-4o
   */
  chat_provider_id?: null | undefined;
  /**
   * The ID of an existing chat to use. If provided, the chat with this ID will be used instead of creating a new one.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  existing_chat_id?: null | undefined;
  /**
   * The IDs of any files attached to this message. These files must already be uploaded to the file_uploads table.
   *
   * @example ["00000000-0000-0000-0000-000000000000"]
   */
  input_files_ids?: string[];
  /**
   * The ID of the message that this message is a response to. If this is the first message in the chat, this should be empty.
   *
   * @format uuid
   * @example 00000000-0000-0000-0000-000000000000
   */
  previous_message_id?: null | undefined;
  /**
   * The text of the message.
   *
   * @example Hello, world!
   */
  user_message: string;
};

/**
 * Response for the token_usage_estimate endpoint
 */
export type TokenUsageResponse = {
  /**
   * Detailed token usage for each file
   */
  file_details: TokenUsageResponseFileItem[];
  /**
   * Overall statistics about token usage
   */
  stats: TokenUsageStats;
};

/**
 * Token usage details for an individual file
 */
export type TokenUsageResponseFileItem = {
  /**
   * The original filename of the file
   */
  filename: string;
  /**
   * The unique ID of the file
   */
  id: string;
  /**
   * Number of tokens used for this file's content
   *
   * @minimum 0
   */
  token_count: number;
};

/**
 * Token usage statistics for the request
 */
export type TokenUsageStats = {
  /**
   * The chat provider ID that was used for this estimation
   */
  chat_provider_id: string;
  /**
   * Number of tokens in file contents
   *
   * @minimum 0
   */
  file_tokens: number;
  /**
   * Number of tokens in previous messages (chat history)
   *
   * @minimum 0
   */
  history_tokens: number;
  /**
   * The configured model's maximum token limit
   *
   * @format int32
   * @minimum 0
   */
  max_tokens: number;
  /**
   * Remaining tokens available for the model response
   *
   * @format int32
   * @minimum 0
   */
  remaining_tokens: number;
  /**
   * Total number of tokens in the request
   *
   * @minimum 0
   */
  total_tokens: number;
  /**
   * Number of tokens in the user message
   *
   * @minimum 0
   */
  user_message_tokens: number;
};

export type ToolCallStatus = "in_progress" | "success" | "error";

export type ToolUse = {
  input?: null | Value;
  output?: null | Value;
  progress_message?: null | undefined;
  status: ToolCallStatus;
  tool_call_id: string;
  tool_name: string;
};

/**
 * Request to update an existing assistant
 */
export type UpdateAssistantRequest = {
  /**
   * Optional new default chat provider
   */
  default_chat_provider?: null | undefined;
  /**
   * Optional new description for the assistant
   */
  description?: null | undefined;
  /**
   * Optional list of file upload IDs to associate with this assistant
   */
  file_ids?: null | undefined;
  /**
   * Optional new list of MCP server IDs
   */
  mcp_server_ids?: null | undefined;
  /**
   * Optional new name for the assistant
   */
  name?: null | undefined;
  /**
   * Optional new prompt for the assistant
   */
  prompt?: null | undefined;
};

/**
 * An assistant with its associated files
 */
export type UpdateAssistantResponse = AssistantWithFiles;

export type UserProfile = {
  /**
   * The user's email address. Shouldn't be used as a unique identifier, as it may change.
   */
  email?: string;
  /**
   * List of groups the user belongs to.
   *
   * This is derived from the `groups` claim in the ID token.
   * If the claim is not present, this will be an empty list.
   */
  groups: string[];
  id: string;
  /**
   * The user's display name.
   */
  name?: string;
  /**
   * Organization group IDs from the `groups` claim.
   *
   * These can be used as subject_id when creating share grants
   * with subject_id_type "organization_group_id".
   */
  organization_group_ids: string[];
  /**
   * Organization user ID from the `oid` claim (Entra ID specific).
   *
   * This can be used as the subject_id when creating share grants
   * with subject_id_type "organization_user_id".
   */
  organization_user_id?: string;
  /**
   * The user's profile picture URL.
   */
  picture?: string;
  /**
   * The user's preferred language.
   *
   * The final determined language is intersected with our supported languages, to determine the final language.
   *
   * Will be a BCP 47 language tag (e.g. "en" or "en-US").
   *
   * This is derived in the following order (highest priority first):
   * - ID token claims
   * - Browser Accept-Language header
   * - Default to "en"
   */
  preferred_language: string;
};

export type Value = void;
